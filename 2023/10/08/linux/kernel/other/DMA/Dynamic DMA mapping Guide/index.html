

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Gao Xiang">
  <meta name="keywords" content="Linux">
  
    <meta name="description" content="Dynamic DMA mapping Guide">
<meta property="og:type" content="article">
<meta property="og:title" content="Xiaoa&#39;s Blog">
<meta property="og:url" content="http://example.com/2023/10/08/linux/kernel/other/DMA/Dynamic%20DMA%20mapping%20Guide/index.html">
<meta property="og:site_name" content="Xiaoa&#39;s Blog">
<meta property="og:description" content="Dynamic DMA mapping Guide">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-08T10:50:46.454Z">
<meta property="article:modified_time" content="2023-10-08T15:26:56.465Z">
<meta property="article:author" content="Gao Xiang">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Xiaoa&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Linux</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E6%B2%99%E6%BC%A0.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-08 18:50" pubdate>
          星期日, 十月 8日 2023, 6:50 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          180 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Dynamic-DMA-mapping-Guide"><a href="#Dynamic-DMA-mapping-Guide" class="headerlink" title="Dynamic DMA mapping Guide"></a>Dynamic DMA mapping Guide</h1><span id="more"></span>
<p>这是一篇指导驱动工程师如何使用 DMA API 的文档，为了方便理解，文档中给出了伪代码的例程。有关 API 的简要描述，请参见 <strong>DMA-API.tx</strong>t。</p>
<h2 id="CPU-虚拟地址和-DMA-总线地址"><a href="#CPU-虚拟地址和-DMA-总线地址" class="headerlink" title="CPU 虚拟地址和 DMA 总线地址"></a>CPU 虚拟地址和 DMA 总线地址</h2><p>在 DMA API中涉及好几个地址的概念（<strong>虚拟地址、物理地址、总线地址</strong>），正确的理解这些地址是非常重要的。</p>
<p>内核通常使用的地址是虚拟地址。我们调用 <code>kmalloc()</code>、<code>vmalloc()</code>或者类似的接口返回的地址都是虚拟地址，保存在<code>&quot;void *&quot;</code>的变量中。</p>
<p>虚拟内存系统（TLB、页表等）将虚拟地址转换成物理地址（CPU角度），物理地址保存在<code>phys_addr_t</code>或<code>resource_size_t</code>变量中。对于一个硬件设备上的寄存器等设备资源，内核是按照物理地址来管理的。通过 <code>/proc/iomem</code>，你可以看到这些和设备 IO 相关的物理地址。当然，驱动并不能直接使用这些物理地址，必须首先通过 <code>ioremap()</code> 接口将这些物理地址映射到内核虚拟地址空间上去。</p>
<p><em>I&#x2F;O</em> 设备使用第三种地址：<strong>总线地址</strong>。如果设备在 MMIO 地址空间中有寄存器，它可以通过 DMA 执行读写系统内存的操作，这时设备使用的地址就是总线地址。在某些系统中，总线地址与 CPU 物理地址相同，但一般来说它们不是。IOMMUs 和 host bridge 可以在物理地址和总线地址之间进行映射。</p>
<p>从设备的角度来看，DMA 控制器使用总线地址空间，不过可能仅限于总线空间的一个子集。例如，即便是一个系统支持 64 位地址内存和 64 位地址的 PCI bar，但是 DMA 可以不使用全部的 64 bit 地址，通过 IOMMU 映射，PCI 设备上的 DMA 可以只使用 32 位 DMA 地址。</p>
<p>这里有一张图片和一些例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">             CPU                  CPU                  Bus<br>           Virtual              Physical             Address<br>           Address              Address               Space<br>            Space                Space<br><br>          +-------+             +------+             +------+<br>          |       |             |MMIO  |   Offset    |      |<br>          |       |  Virtual    |Space |   applied   |      |<br>        C +-------+ --------&gt; B +------+ ----------&gt; +------+ A<br>          |       |  mapping    |      |   by host   |      |<br>+-----+   |       |             |      |   bridge    |      |   +--------+<br>|     |   |       |             +------+             |      |   |        |<br>| CPU |   |       |             | RAM  |             |      |   | Device |<br>|     |   |       |             |      |             |      |   |        |<br>+-----+   +-------+             +------+             +------+   +--------+<br>          |       |  Virtual    |Buffer|   Mapping   |      |<br>        X +-------+ --------&gt; Y +------+ &lt;---------- +------+ Z<br>          |       |  mapping    | RAM  |   by IOMMU<br>          |       |             |      |<br>          |       |             |      |<br>          +-------+             +------+<br></code></pre></td></tr></table></figure>

<p>在 PCI 枚举过程中，内核了解 I&#x2F;O 设备及其 MMIO 空间，以及将它们连接到系统的主机桥接起来。例如，如果 PCI 设备有一个 BAR（base address register），内核从 BAR 中读取总线地址 <strong>(A)</strong> 并将其转换为 CPU 物理地址 **(B)**。地址 <strong>B</strong> 存储在 <code>struct resource</code> 中，通常通过 <code>/proc/iomem</code> 暴露给用户。当驱动程序声明一个设备时，它通常使用<code>ioremap()</code> 将物理地址 <strong>B</strong> 映射到虚拟地址 **(C)**。然后它可以使用例如 <code>ioread32(C)</code> 来访问总线地址 A 的设备寄存器。</p>
<p>如果设备支持 DMA，驱动程序使用 <code>kmalloc()</code> 或类似的接口建立一个缓冲区，返回一个虚拟地址 **(X)**，虚拟内存系统将 <strong>X</strong> 映射到系统 RAM 中的物理地址 **(Y)**。驱动程序可以使用虚拟地址 <strong>X</strong> 访问缓冲区，但是设备本身不能，因为 DMA不经过 CPU 虚拟内存系统。</p>
<p>在一些简单的系统中，设备可以通过 DMA 直接访问物理地址 <strong>Y</strong>，但是在大多数的系统中，有一个 IOMMU 的硬件用来将 DMA 可访问的<strong>总线地址</strong>转换成<strong>物理地址</strong>，也就是把上图中的地址 <strong>Z</strong> 转换成 <strong>Y</strong>。理解了这些底层硬件，你也就知道类似 <code>dma_map_single</code> 这样的 DMA API 是在做什么了。驱动在调用 <code>dma_map_single</code> 接口函数的时候会传递一个虚拟地址 <strong>X</strong>，在这个函数中会设定 IOMMU 的页表，将地址 <strong>X</strong> 映射到 <strong>Z</strong>，并且将返回 <strong>Z</strong> 这个总线地址。驱动可以把 <strong>Z</strong> 总线地址设定到设备上的 DMA 相关寄存器中。这样，当设备发起对<strong>总线地址 Z</strong> 的DMA 操作时，IOMMU 就进行地址映射，并将 DMA 操作定位到 <strong>Y</strong> 地址开始的 DMA buffer。</p>
<p>根据上面的描述我们可以得出这样的结论：Linux 可以使用动态 DMA 映射（<strong>dynamic DMA mapping</strong>）的方法，当然，这需要一些来自驱动的协助。所谓动态 DMA 映射是指只有在使用的时候，才建立 DMA buffer 虚拟地址到总线地址的映射，一旦 DMA 传输完毕，就将之前建立的映射关系销毁。</p>
<p>虽然上面的例子使用 IOMMU 为例描述，不过本文随后描述的 API 也可以在没有 IOMMU 硬件的平台上运行。</p>
<p>顺便说明一点：DMA API 适用于各种处理器架构，DMA mapping framework 已经屏蔽了底层硬件的细节。对于驱动工程师而言，你应该使用通用的 DMA API（例如 <code>dma_map_*()</code> 接口函数），而不是和特定总线相关的 API（例如<code>pci_map_*()</code> 接口函数）。</p>
<p>驱动想要使用 DMA mapping framework 的 API，需要首先包含相关头文件：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/dma-mapping.h&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>这个头文件中定义了 <code>dma_addr_t</code> 这种数据类型，而这种类型的变量可以保存任何有效的 DMA 地址，不管是什么总线，什么处理器架构。驱动调用了 DMA API 之后，返回的 DMA 地址（总线地址）就是这种类型的。</p>
<h2 id="什么地址可以用作-DMA"><a href="#什么地址可以用作-DMA" class="headerlink" title="什么地址可以用作 DMA"></a>什么地址可以用作 DMA</h2><p>既然驱动想要使用 DMA mapping framework 提供的接口，我们首先需要知道的就是是否所有的系统内存都是可以调用DMA API 进行映射？那么这些可以让 DMA 控制器访问系统内存有什么特点？关于这一点，一直以来有一些不成文的规则，在本文中我们看看是否能够将其全部记录下来。</p>
<p>如果驱动是通过伙伴系统的接口（例如 <code>__get_free_page*()</code>）或者类似 <code>kmalloc()</code>、 <code>kmem_cache_alloc()</code>这样的通用内存分配的接口来分配 DMA buffer，那么这些接口函数返回的虚拟地址可以直接用于 DMA mapping 接口API，并通过 DMA 操作在外设和 dma buffer 中交换数据。</p>
<p>使用 <code>vmalloc()</code> 分配的 DMA buffer 可以直接使用吗？最好不要这样，虽然强行使用也没有问题，但是终究是比较麻烦。首先，<code>vmalloc</code> 分配的物理页面是不连续的，如果底层硬件需要物理内存连续，那么 <code>vmalloc</code> 分配的内存不能满足硬件要求。即便是底层 DMA 硬件支持 scatter-gather，<code>vmalloc</code> 分配出来的内存仍然存在其他问题。我们知道 <code>vmalloc</code> 分配的虚拟地址和对应的物理地址没有线性关系（<code>kmalloc</code> 或者 <code>__get_free_page</code> 这样的接口，其返回的虚拟地址和物理地址有一个固定偏移的关系，即 PAGE_OFFSET），而在做 DMA mapping 的时候，需要知道物理地址，有线性关系的虚拟地址很容易可以获取其物理地址，但是对于 <code>vmalloc</code> 分配的虚拟地址，我们需要遍历页表才可以找到其物理地址。</p>
<p>该规则还意味着您既不能使用内核映像地址(data&#x2F;text&#x2F;bss 段)，也不能使用内核模块映像地址，即使这些内存可以物理地使用DMA。您也需要确保 I&#x2F;O 缓冲区与 cache line 对齐。否则会有 cpu 和 dma 都写同一个 cache line 而导致数据被覆盖的问题。</p>
<p>通过 <code>kmap</code> 接口返回的内存也可以做 DMA buffe，其原理类似 <code>vmalloc</code>。</p>
<p>块设备和网络设备使用的 buffer 可以确保可以使用 DMA 操作。</p>
<h2 id="DMA-地址的限制"><a href="#DMA-地址的限制" class="headerlink" title="DMA 地址的限制"></a>DMA 地址的限制</h2><p>你的设备有 DMA 地址的限制吗？比如你的设备只能访问低 24 的内存地址，如果是这样，你需要把这个限制告诉内核。</p>
<p>默认情况下，内核可以确保你的设备可以访问全部的 32 位地址空间。对于 64 位也一样。</p>
<p>关于 PCI 的特别注意事项: PCI- x 规范要求 PCI- x 设备支持所有事务的 64 位寻址。当 IO 总线处于 PCI-X 模式时，至少有一个平台(SGI SN2)需要 64 位一致的分配才能正确运行。</p>
<p>如果有寻址限制，那么在该外设驱动的 probe 函数中，你需要询问内核，看看是否有 DMA controller 可以支持这个外设的寻址限制。虽然有缺省的寻址限制的设定，不过最好还是在 probe 函数中进行相关处理，至少这说明你已经为你的外设考虑过寻址限制这事了。</p>
<p>一旦确定了设备 DMA 寻址限制之后，我们可以通过下面的接口进行设定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_mask_and_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span>;<br></code></pre></td></tr></table></figure>

<p>上面的接口用询问 streaming 和 coherent 两种 dma buffer</p>
<p>根据 DMA buffer 的特性，DMA 操作有两种：</p>
<ul>
<li><strong>streaming</strong>：DMA buffer 是一次性的，用完就算。但是需要自己考虑 cache 一致性</li>
<li><strong>cache coherent</strong>：这种 DMA buffer 往往是静态的、长时间存在的。</li>
</ul>
<p>如果你知道你想用的是哪种接口，那旧直接调用对应的接口</p>
<p>streaming 接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span>;<br></code></pre></td></tr></table></figure>

<p>consistent allocations 接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_coherent_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span>;<br></code></pre></td></tr></table></figure>

<p><code>dev</code> 指向该设备的 <code>struct device</code> 对象，一般来说，这个 <code>struct device</code> 对象应该是嵌入在 bus-specific 的实例中，例如对于 PCI 设备，有一个 <code>struct pci_dev</code> 的实例与之对应，而在这里需要传入的 <code>dev</code> 参数则可以通过 <code>&amp;pdev-&gt;dev</code> 得到（<code>pdev</code> 指向 <code>struct pci_dev</code> 的实例）。<code>mask</code> 表示你的设备支持的地址信息。</p>
<p>如果返回值非 0，那么说明这样的 DMA 寻址是不能正确完成的，如果强行这么做将会产生不可预知的后果。驱动必须检测返回值，如果不行，那么建议修改 mask 或者不使用DMA。</p>
<p>也就是说，对上面接口调用失败后，你有三个选择：</p>
<ul>
<li>使用另一个 DMA mask</li>
<li>使用非 DMA 方式</li>
<li>忽略这个设备，不初始化它</li>
</ul>
<p>标准的 32 位寻址设备会这样做:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="hljs-number">32</span>))) &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: No suitable DMA available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一个常见的场景是有 64 位寻址能力的设备。一般来说我们会首先尝试设定 64 位的地址掩码，但是这时候有可能会失败，从而将掩码降低为 3 2位。内核之所以会在设定 64 位掩码的时候失败，这并不是因为平台不能进行 64 位寻址，而仅仅是因为 32 位寻址比 64 位寻址效率更高。例如，SPARC64 平台上，PCI SAC 寻址比 DAC 寻址性能更好。</p>
<p>下面就是如何使用 streaming 的 DMA 来配置 64 位设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> using_dac;<br><br><span class="hljs-keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="hljs-number">64</span>))) &#123;<br>    using_dac = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="hljs-number">32</span>))) &#123;<br>    using_dac = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: No suitable DMA available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要使用 dma coherent 的方式来配置 64 位设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> using_dac, consistent_using_dac;<br><br><span class="hljs-keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="hljs-number">64</span>))) &#123;<br>    using_dac = <span class="hljs-number">1</span>;<br>    consistent_using_dac = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="hljs-number">32</span>))) &#123;<br>    using_dac = <span class="hljs-number">0</span>;<br>    consistent_using_dac = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: No suitable DMA available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>coherent 地址掩码总是等于或者小于 streaming 地址掩码，因此，一般来说，我们只要设定了 streaming 地址掩码成功了，那么使用同样的掩码或者小一些的掩码来设定 coherent 地址掩码总是会成功，因此这时候我们一般就不检查 <code>dma_set_coherent_mask</code> 的返回值了，当然，有些设备很奇怪，只能使用 coherent DMA，那么这种情况下，驱动需要检查 <code>dma_set_coherent_mask</code> 的返回值。</p>
<p>最后，如果你的设备只能使用低 24 位的地址空间，你应该这样设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (dma_set_mask(dev, DMA_BIT_MASK(<span class="hljs-number">24</span>))) &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: 24-bit DMA addressing not available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当 <code>dma_set_mask()</code> 或 <code>dma_set_mask_and_coherent()</code> 返回 0，说明成功了，内核一定要保存好这个 mask。因为一会要用这个 mask 调用 dma mapping 接口。</p>
<p>这里还有一个需要提到的场景：比如一个声卡设备提供了播放和录音功能，每个功能都需要 dma，而两个需要的 dma 地址范围又不一样，所以需要分别调用 <code>dma_set_mask()</code>l来设置。</p>
<p>下面是段伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLAYBACK_ADDRESS_BITS	DMA_BIT_MASK(32)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RECORD_ADDRESS_BITS	DMA_BIT_MASK(24)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_sound_card</span> *<span class="hljs-title">card</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br><br>...<br><span class="hljs-keyword">if</span> (!dma_set_mask(dev, PLAYBACK_ADDRESS_BITS)) &#123;<br>    card-&gt;playback_enabled = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    card-&gt;playback_enabled = <span class="hljs-number">0</span>;<br>    dev_warn(dev, <span class="hljs-string">&quot;%s: Playback disabled due to DMA limitations\n&quot;</span>,<br>           card-&gt;name);<br>&#125;<br><span class="hljs-keyword">if</span> (!dma_set_mask(dev, RECORD_ADDRESS_BITS)) &#123;<br>    card-&gt;record_enabled = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    card-&gt;record_enabled = <span class="hljs-number">0</span>;<br>    dev_warn(dev, <span class="hljs-string">&quot;%s: Record disabled due to DMA limitations\n&quot;</span>,<br>           card-&gt;name);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="DMA-mappings-的类型"><a href="#DMA-mappings-的类型" class="headerlink" title="DMA mappings 的类型"></a>DMA mappings 的类型</h2><p>有两种类型的 DMA mapping 接口</p>
<h3 id="Consistent-DMA-mappings"><a href="#Consistent-DMA-mappings" class="headerlink" title="Consistent DMA mappings"></a>Consistent DMA mappings</h3><ul>
<li>它总是在驱动初始化的时候进行 map，在硬件结束的时候 unmap。</li>
<li>CPU 和 DMA controller 在发起对 DMA buffer 的并行访问的时候不需要考虑 cache 的影响，也就是说不需要软件进行 cache 操作，CPU 和 DMA controller 都可以看到对方对 DMA buffe r的更新。</li>
</ul>
<p>实际上一致性 DMA 映射中的那个 consistent 实际上可以称为 <code>synchronous</code> 或 <code>coherent</code>，即 cache coherent。</p>
<p>缺省情况下，coherent mask 被设定为低 32 bit，即使这样可以满足驱动的需求，但为了将来的兼容性，也建议你通过接口在驱动中设定 coherent mask。</p>
<p>下面有一些 dma coherent mapping 的好的例子：</p>
<ul>
<li>网卡驱动和网卡 DMA 控制器往往是通过一些内存中的描述符（形成环或者链）进行交互，这些保存描述符的内存一般采用 Consistent DMA mapping</li>
<li>SCSI 硬件适配器上的 DMA 使用一些数据结构（mailbox command）进行交互，这些保存 mailbox command 的内存一般采用 Consistent DMA mapping。</li>
<li>有些外设有能力执行主存上的固件代码（microcode），这些保存 microcode 的主存一般采用 Consistent DMA mapping。</li>
</ul>
<p>上面的这些例子有同样的特性：cpu 对内存的修改可以立刻被外设感知到，反之亦然，一致性映射可以保证这一点。</p>
<p>需要注意的是：一致性的 DMA 映射并不意味着不需要 memory barriers 来保证内存顺序，CPU 有可能为了性能而重排对 consistent memory 上内存访问指令。例如：如果在DMA consistent memory 上有两个 word，分别是 word0 和 word1，对于 device 一侧，必须保证 word0 先更新，然后才有对 word1 的更新，那么你需要这样写代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">desc-&gt;word0 = address;<br>wmb();<br>desc-&gt;word1 = DESC_VALID;<br></code></pre></td></tr></table></figure>

<p>只有这样才能保证在所有的平台上的设备驱动可以正常的工作。</p>
<p>此外，在有些平台上，修改了 DMA Consistent buffer 后，你的驱动可能需要 flush write buffer，以便让 device 侧感知到 memory 的变化。这个动作类似在 PCI 桥中的 flush write buffer 的动作。</p>
<h3 id="Streaming-DMA-mappings"><a href="#Streaming-DMA-mappings" class="headerlink" title="Streaming DMA mappings"></a>Streaming DMA mappings</h3><p>流式 DMA 映射是一次性的，一般是需要进行 DMA 传输的时候才进行 mapping，一旦DMA 传输完成，就立刻 ummap（除非你使用 dma_sync_*的接口，下面会描述）。并且硬件可以为顺序化访问进行优化。</p>
<p>streaming 可以被认为是 asynchronous，或者是不属于 coherent memory 范围</p>
<p>下面有几个使用 streaming mapping 好的例子：</p>
<ul>
<li>网卡进行数据传输使用的 DMA buffer</li>
<li>文件系统中的各种数据 buffer，这些 buffer 中的数据最终到读写到 SCSI 设备上去，一般而言，驱动会接受这些 buffer，然后进行 streaming DMA mapping，之后和 SCSI 设备上的 DMA 进行交互。</li>
</ul>
<p>设计 streaming DMA mapping 这样的接口是为了充分优化硬件的性能，为了达到这个目标，在使用这些接口的时候，你必须清清楚楚的知道调用接口会发生什么。</p>
<p>无论哪种类型的 DMA 映射都有对齐的限制，这些限制来自底层的总线，当然也有可能是某些总线上的设备有这样的限制。此外，如果系统中的 cache 并不是 DMA coherent 的，而且底层的 DMA buffer 不和其他数据共享 cacheline，这样的系统将工作的更好。</p>
<h3 id="如何使用-Consistent-DMA-mappings"><a href="#如何使用-Consistent-DMA-mappings" class="headerlink" title="如何使用 Consistent DMA mappings"></a>如何使用 Consistent DMA mappings</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>为了分配并映射一个较大（PAGE_SIZE 大小或者类似）的 coherent DMA memory，你需要调用下面的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle;<br>cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);<br></code></pre></td></tr></table></figure>

<p>DMA 操作总是会涉及具体设备上的 DMA controller，而 <code>dev</code> 参数就是执行该设备的<code>struct device</code> 对象的。</p>
<p><code>size</code> 参数指明了你想要分配的 DMA Buffer 的大小，byte 为单位</p>
<p><code>dma_alloc_coherent</code> 这个接口也可以在中断上下文调用，当然，<code>gfp</code> 参数要传递 <code>GFP_ATOMIC</code> 标记，<code>gfp</code> 是内存分配的 flag，<code>dma_alloc_coherent</code> 仅仅是透传该 flag 到内存管理模块。</p>
<p>如果传入非空的 <code>dev</code> 参数，即使驱动调用了掩码设置接口函数设定了 DMA mask，说明该设备可以访问大于 32 位地址空间，一致性 DMA 映射的接口函数也一般会默认的返回一个 32 位可寻址的 DMA buffer 地址。要知道 dma mask 和 coherent dma mask 是不同的，除非驱动显示的调用 <code>dma_set_coherent_mask()</code> 接口来修改 coherent dma mask，例如大小大于 32 位地址，<code>dma_alloc_coherent</code> 接口函数才会返回大于 32 位地址空间的地址。dma pool 接口也是如此。</p>
<p><code>dma_alloc_coherent</code> 函数返回两个值，一个是从 cpu 角度访问 DMA buffer 的虚拟地址，另外一个是从设备（DMA controller）角度看到的总线地址：<code>dma_handle</code>，驱动可以将这个总线地址传递给硬件。</p>
<p>即便是请求的 DMA buffer 的大小小于 PAGE SIZE，<code>dma_alloc_coherent</code> 返回的 cpu虚拟地址和 DMA 总线地址都保证对齐在最小的 PAGE_SIZE 上，这个特性确保了分配的DMA buffer 有这样的特性：如果 PAGE_SIZE 是 64K，即便是驱动分配一个小于或者等于64K 的dma buffer，那么 DMA buffer 不会越过 64K 的边界。</p>
<h4 id="unmap"><a href="#unmap" class="headerlink" title="unmap"></a>unmap</h4><p>当驱动需要 umap 并释放 dma buffer 的时候，需要调用下面的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_free_coherent(dev, size, cpu_addr, dma_handle);<br></code></pre></td></tr></table></figure>

<p>这个接口函数的 <code>dev</code>、<code>size</code> 参数上面已经描述过了，而 <code>cpu_addr</code> 和 <code>dma_handle</code> 参数就是 <code>dma_alloc_coherent()</code> 接口的那两个地址返回值。需要强调的一点就是：和 <code>dma_alloc_coherent</code> 不同，<code>dma_free_coherent</code> 不能在中断上下文中调用。（因为在有些平台上，free DMA 的操作会引发 TLB 维护的操作（从而引发cpu core 之间的通信），如果关闭了中断会锁死在 SMP IPI 的代码中）。</p>
<h4 id="dma-pool"><a href="#dma-pool" class="headerlink" title="dma_pool"></a>dma_pool</h4><p>如果你的驱动需非常多的小 的dma buffer，那么 dma pool 是最适合你的机制。这个概念类似 <code>kmem_cache</code>。dma pool 就是通过 <code>dma_alloc_coherent</code> 接口获取大块一致性的 DMA 内存，然后驱动可以调用 <code>dma_pool_alloc</code> 从那个大块 DMA 内存中分一个小块的 dma buffer 供自己使用。</p>
<p>创建一个 <code>dma_pool</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_pool</span> *<span class="hljs-title">pool</span>;</span><br>pool = dma_pool_create(name, dev, size, align, boundary);<br></code></pre></td></tr></table></figure>

<p>从 <code>dma_pool</code> 分配内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu_addr = dma_pool_alloc(pool, flags, &amp;dma_handle);<br></code></pre></td></tr></table></figure>

<p>释放 dma 内存到 <code>dma_pool</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_pool_free(pool, cpu_addr, dma_handle);<br></code></pre></td></tr></table></figure>

<p>销毁 <code>dma_pool</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_pool_destroy(pool);<br></code></pre></td></tr></table></figure>

<p>你必须保证在调用 <code>dma_pool_destroy</code> 之前先调用 <code>dma_pool_free</code>，并且这个函数不能在中断上下文中调用。</p>
<h3 id="DMA-操作方向"><a href="#DMA-操作方向" class="headerlink" title="DMA 操作方向"></a>DMA 操作方向</h3><p>由于下面的章节会用到 DMA 操作方向这个概念，因此我们先简单的描述一下，DMA 操作方向定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">DMA_BIDIRECTIONAL<br>DMA_TO_DEVICE<br>DMA_FROM_DEVICE<br>DMA_NONE<br></code></pre></td></tr></table></figure>

<p>如果你知道的话，你应该尽可能的提供准确的 DMA 操作方向。</p>
<p><strong>DMA_TO_DEVICE</strong> 表示从内存（dma buffer）到设备，而 **DMA_FROM_DEVICE **表示从设备到内存（dma buffer），上面的这些字符定义了数据在 DMA 操作中的移动方向。</p>
<p>虽然我们强烈要求驱动在知道 DMA 传输方向的适合，精确的指明是 <strong>DMA_TO_DEVICE</strong> 或者 <strong>DMA_FROM_DEVICE</strong>。</p>
<p>如果你确实是不知道具体的操作方向，那么设定为 **DMA_BIDIRECTIONAL **也是可以的，表示 DMA 操作可以执行任何一个方向的的数据搬移。你的平台需要保证这一点可以让 DMA正常工作，当然，这也有可能会引入一些性能上的额外开销。</p>
<p><strong>DMA_NONE</strong> 主要是用于调试。在驱动知道精确的 DMA 方向之前，可以把它保存在 DMA控制数据结构中，在 dma 方向设定有问题的时候，你可以跟踪 dma 方向的设置情况，以便定位问题所在。</p>
<p>除了潜在的平台相关的性能优化之外，精确地指定 DMA 操作方向还有另外一个优点就是方便调试。有些平台实际上在创建 DMA mapping 的时候，页表（将总线地址映射到物理地址的页表）中有一个写权限布尔值，这个值非常类似于用户程序地址空间中的页保护。当 DMA 控制器硬件检测到违反权限设置时，这样的平台可以将错误写入内核日志，从而方便了调试。</p>
<p>只有 streaming mappings 才会指明 DMA 操作方向，一致性 DMA 映射隐含的 DMA 操作方向是 <code>DMA_BIDIRECTIONAL</code>。我们举一个 streaming mappings 的例子：在网卡驱动中，如果要发送数据，那么在 map&#x2F;umap 的时候需要指明 <code>DMA_TO_DEVICE</code> 的操作方向，而在接受数据包的时候，map&#x2F;umap 需要指明 DMA 操作方向是<code>DMA_FROM_DEVICE</code>。</p>
<h3 id="如何使用-Streaming-DMA-mappings"><a href="#如何使用-Streaming-DMA-mappings" class="headerlink" title="如何使用 Streaming DMA mappings"></a>如何使用 Streaming DMA mappings</h3><p>streaming DMA mapping 的接口函数可以在中断上下文中调用。streaming DMA mapping有两个版本的接口函数，一个是用来 map&#x2F;umap 单个的 dma buffer，另外一个是用来map&#x2F;umap 形成 scatterlist 的多个 dma buffer。</p>
<h4 id="dma-map-single"><a href="#dma-map-single" class="headerlink" title="dma_map_single"></a>dma_map_single</h4><p>map 单个 dma buf：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;my_dev-&gt;dev;<br><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-type">void</span> *addr = buffer-&gt;ptr;<br><span class="hljs-type">size_t</span> size = buffer-&gt;len;<br><br>dma_handle = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>unmap 单个 dma buf：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_unmap_single(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure>

<p>当调用 <code>dma_map_single()</code> 返回错误的时候，你应当调用 <code>dma_mapping_error()</code> 来处理错误。虽然并不是所有的 DMA mapping 实现都支持 <code>dma_mapping_error</code> 这个接口（调用 <code>dma_mapping_error</code> 函数实际上会调用底层 <code>dma_map_ops</code> 操作函数集中的 <code>mapping_error</code> 成员函数），但是调用它来进行出错处理仍然是一个好的做法。这样做的好处是可以确保 DMA mapping 代码在所有 DMA 实现中都能正常工作，而不需要依赖底层实现的细节。没有检查错误就使用返回的地址可能会导致程序失败，可能会产生 kernel panic 或者悄悄的损坏你有用的数据。虽然是这里使用 <code>dma_map_single</code> 作为示例，但同样也是适用于<code>dma_map_page</code>。</p>
<p>当 DMA 传输完成的时候，程序应该调用 <code>dma_unmap_single()</code> 函数 umap dma buffer。例如：在 DMA 完成传输后会通过中断通知 CPU，而在中断函数中可以调用<code>dma_unmap_single()</code> 函数。<code>dma_map_single</code> 函数在进行 DMA mapping 的时候使用的是 cpu 指针（虚拟地址），这样就导致该函数有一个弊端：不能使用 HIGHMEM memory 进行映射（因为不能线性映射）。鉴于此，map&#x2F;unmap 接口提供了另外一个类似的接口，这个接口不使用 cpu 指针，而是使用 page 和 page offset 来进行 DMA mapping（返回 <code>struct page</code> 数据结构，后续可以根据 page 线性转换为内核虚拟地址）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;my_dev-&gt;dev;<br><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> buffer-&gt;page;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset = buffer-&gt;offset;<br><span class="hljs-type">size_t</span> size = buffer-&gt;len;<br><br>dma_handle = dma_map_page(dev, page, offset, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * reduce current DMA mapping usage,</span><br><span class="hljs-comment">	 * delay and try again later or</span><br><span class="hljs-comment">	 * reset driver.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">goto</span> map_error_handling;<br>&#125;<br><br>...<br><br>dma_unmap_page(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure>

<p><code>offset</code> 表示一个指定 page 内的页内偏移（以Byte为单位）。和 <code>dma_map_single</code> 接口函数一样，调用 <code>dma_map_page()</code> 返回错误后需要调用 <code>dma_mapping_error()</code> 来进行错误处理。</p>
<p>当 DMA 传输完成的时候，你应该调用 <code>dma_unmap_page()</code> 函数 umap dma buffer。例如：在 DMA 完成传输后会通过中断通知 cpu，而在中断函数中可以调用<code>dma_unmap_page()</code> 函数。</p>
<h4 id="dma-map-sg"><a href="#dma-map-sg" class="headerlink" title="dma_map_sg"></a>dma_map_sg</h4><p>在 scatterlist 的情况下，你要映射的对象是分散的若干段 DMA buffer，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i, count = dma_map_sg(dev, sglist, nents, direction);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scatterlist</span> *<span class="hljs-title">sg</span>;</span><br><br>for_each_sg(sglist, sg, count, i) &#123;<br>    hw_address[i] = sg_dma_address(sg);<br>    hw_len[i] = sg_dma_len(sg);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>nents</code> 说明了 sglist 中条目的数量（即 map 多少段 dma buffer）。</p>
<p>具体 DMA 映射的实现是自由的，它可以把 scatterlist 中的若干段连续的 DMA buffer 映射成一个大块的，连续的总线地址空间。例如：如果 DMA mapping 是以 PAGE_SIZE 为粒度进行映射，那么那些分散的一块块的 dma buffer 可以被映射到一个对齐在 PAGE_SIZE 上，然后各个 dma buffer 依次首尾相接在一个大的总线地址区域上。这样做的好处就是对于那些不支持（或者支持有限）scatter-gather 的 DMA controller，仍然可以通过 mapping 来实现。<code>dma_map_sg</code> 调用失败的时候返回 0，当调用成功的时候，返回成功mapping 的数目。</p>
<p>一旦调用成功，你需要调用 <code>for_each_sg</code> 来遍历所有成功映射的 mappings（这个数目可能会小于 <code>nents</code>）并且使用 <code>sg_dma_address()</code> 和 <code>sg_dma_len()</code> 这两个宏来得到 mapping 后的 dma 地址和长度。</p>
<p>umap 一个 scatterlist：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_unmap_sg(dev, sglist, nents, direction);<br></code></pre></td></tr></table></figure>

<p>再次强调，调用 <code>dma_unmap_sg</code> 的时候要确保 DMA 操作已经完成。</p>
<p>另外，传递给 <code>dma_unmap_sg</code> 的 <code>nents</code> 参数需要等于传递给 <code>dma_map_sg</code> 的 <code>nents</code>参数，而不是该函数返回的 <code>count</code>。</p>
<p>由于 DMA 地址空间是共享资源，每一次 <code>dma_map_&#123;single,sg&#125;()</code> 的调用都需要有其对应的 <code>dma_unmap_&#123;single,sg&#125;()</code>，如果你总是分配 dma 地址资源而不回收，那么系统将会由于 DMA address 被用尽而陷入不可用的状态。</p>
<h5 id="dma-sync-xxx"><a href="#dma-sync-xxx" class="headerlink" title="dma_sync_xxx"></a>dma_sync_xxx</h5><p>如果你需要多次访问同一个 streaming DMA buffer，并且在 DMA 传输之间读写 DMA Buffer 上的数据，这时候你需要小心进行 DMA buffer 的 sync 操作，以便 cpu 和设备可以看到最新的、正确的数据。</p>
<p>首先用 <code>dma_map_&#123;single,sg&#125;()</code> 进行映射，在完成 DMA 传输之后，需要调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_single_for_cpu(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_sg_for_cpu(dev, sglist, nents, direction);<br></code></pre></td></tr></table></figure>

<p>如果，cpu 操作了 DMA buffer 的数据，然后你又想把控制权交给设备上的 DMA 控制器，让 DMA controller 访问 DMA buffer，这时候，在真正让HW（指DMA控制器）去访问DMA buffer之前，你需要调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_single_for_device(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_sg_for_device(dev, sglist, nents, direction);<br></code></pre></td></tr></table></figure>

<p>为了让 device 可以看到 cpu 更新后的数据。此外，需要强调的是：传递给<code>dma_sync_sg_for_cpu()</code> 和 <code>dma_sync_sg_for_device()</code> 的 <code>ents</code> 参数需要等于传递给 <code>dma_map_sg</code> 的 <code>nents</code> 参数，而不是该函数返回的 <code>count</code>。</p>
<p>在完成最后一次 DMA 传输之后，你需要调用 DMA unmap 函数 <code>dma_unmap_&#123;single,sg&#125;()</code>。</p>
<p>如果在第一次调用 <code>dma_map_*()</code> 和 <code>dma_unmap_*()</code> 之间，你从来都没有碰过 DMA buffer 中的数据，那么你根本不需要调用 <code>dma_sync_*()</code> 这样的 sync 操作。</p>
<p>下面的伪代码显示了需要使用 <code>dma sync *()</code> 接口的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c">my_card_setup_receive_buffer(<span class="hljs-keyword">struct</span> my_card *cp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)<br>&#123;<br>    <span class="hljs-type">dma_addr_t</span> mapping;<br><br>    mapping = dma_map_single(cp-&gt;dev, buffer, len, DMA_FROM_DEVICE);<br>    <span class="hljs-keyword">if</span> (dma_mapping_error(cp-&gt;dev, mapping)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * reduce current DMA mapping usage,</span><br><span class="hljs-comment">         * delay and try again later or</span><br><span class="hljs-comment">         * reset driver.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">goto</span> map_error_handling;<br>    &#125;<br><br>    cp-&gt;rx_buf = buffer;<br>    cp-&gt;rx_len = len;<br>    cp-&gt;rx_dma = mapping;<br><br>    give_rx_buf_to_card(cp);<br>&#125;<br><br>...<br><br>my_card_interrupt_handler(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *devid, <span class="hljs-keyword">struct</span> pt_regs *regs)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_card</span> *<span class="hljs-title">cp</span> =</span> devid;<br><br>    ...<br>    <span class="hljs-keyword">if</span> (read_card_status(cp) == RX_BUF_TRANSFERRED) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_card_header</span> *<span class="hljs-title">hp</span>;</span><br><br>        <span class="hljs-comment">/* Examine the header to see if we wish</span><br><span class="hljs-comment">         * to accept the data.  But synchronize</span><br><span class="hljs-comment">         * the DMA transfer with the CPU first</span><br><span class="hljs-comment">         * so that we see updated contents.</span><br><span class="hljs-comment">         */</span><br>        dma_sync_single_for_cpu(&amp;cp-&gt;dev, cp-&gt;rx_dma,<br>                    cp-&gt;rx_len,<br>                    DMA_FROM_DEVICE);<br><br>        <span class="hljs-comment">/* Now it is safe to examine the buffer. */</span><br>        hp = (<span class="hljs-keyword">struct</span> my_card_header *) cp-&gt;rx_buf;<br>        <span class="hljs-keyword">if</span> (header_is_ok(hp)) &#123;<br>            dma_unmap_single(&amp;cp-&gt;dev, cp-&gt;rx_dma, cp-&gt;rx_len,<br>                     DMA_FROM_DEVICE);<br>            pass_to_upper_layers(cp-&gt;rx_buf);<br>            make_and_setup_new_rx_buf(cp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/* CPU should not write to</span><br><span class="hljs-comment">             * DMA_FROM_DEVICE-mapped area,</span><br><span class="hljs-comment">             * so dma_sync_single_for_device() is</span><br><span class="hljs-comment">             * not needed here. It would be required</span><br><span class="hljs-comment">             * for DMA_BIDIRECTIONAL mapping if</span><br><span class="hljs-comment">             * the memory was modified.</span><br><span class="hljs-comment">             */</span><br>            give_rx_buf_to_card(cp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当使用了这套 DMA mapping 接口后，驱动不应该再使用 <code>virt_to_bus()</code> 这个接口了，当然 <code>bus_to_virt()</code> 也不行。不过，如果你的驱动使用了这些接口怎么办呢？其实这套新的 DMA mapping 接口没有和 <code>virt_to_bus</code>、<code>bus_to_virt()</code>一一对应的接口，因此，为了让你的程序能工作，你需要对驱动程序进行小小的修改：你必须要保存从<code>dma_alloc_coherent()</code>、<code>dma_pool_alloc() </code>以及 <code>dma_map_single()</code> 接口函数返回的 dma 地址（对于 <code>dma_map_sg()</code> 这个接口，dma 地址保存在 scatterlist 中，当然这需要硬件支持 dynamic DMA mapping ）,并把这个 dma 地址保存在驱动的数据结构中，并且同时&#x2F;或者保存在硬件的寄存器中。</p>
<p>所有的驱动代码都需要迁移到 DMA mapping framework 的接口函数上来。目前内核已经计划完全移除 <code>virt_to_bus()</code> 和 <code>bus_to_virt()</code> 这两个函数，因为它们已经过时了。有些平台由于不能正确的支持 <code>virt_to_bus()</code> 和 <code>bus_to_virt()</code>，因此根本就没有提供这两个接口。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>DMA 地址空间在某些 cpu 架构上是有限的，因此分配并映射可能会产生错误，我们可以通过下面的方法来判定是否发生了错误：</p>
<ul>
<li><p>检查是否 <code>dma_alloc_coherent()</code> 返回了 <code>NULL</code> 或者 <code>dma_map_sg</code> 返回 0</p>
</li>
<li><p>通过 <code>dma_mapping_error</code> 函数检查 <code>dma_map_single</code> 和 <code>dma_map_page</code> 返回的 dma 地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle;<br><br>dma_handle = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>当在 mapping 多个 page 的时候，如果中间发生了 <code>mapping error</code>，那么需要对那些已经 mapped 的 page 进行 unmap 的操作。下面的示例代码用 <code>dma_map_single</code>函数，对于 <code>dma_map_page</code> 也一样适用。</p>
<p>示例一：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle1;<br><span class="hljs-type">dma_addr_t</span> dma_handle2;<br><br>dma_handle1 = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle1)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling1;<br>&#125;<br>dma_handle2 = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle2)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling2;<br>&#125;<br><br>...<br><br>map_error_handling2:<br>    dma_unmap_single(dma_handle1);<br>map_error_handling1:<br></code></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * if buffers are allocated in a loop, unmap all mapped buffers when</span><br><span class="hljs-comment"> * mapping error is detected in the middle</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">dma_addr_t</span> dma_addr;<br><span class="hljs-type">dma_addr_t</span> <span class="hljs-built_in">array</span>[DMA_BUFFERS];<br><span class="hljs-type">int</span> save_index = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; DMA_BUFFERS; i++) &#123;<br><br>    ...<br><br>    dma_addr = dma_map_single(dev, addr, size, direction);<br>    <span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_addr)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * reduce current DMA mapping usage,</span><br><span class="hljs-comment">         * delay and try again later or</span><br><span class="hljs-comment">         * reset driver.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">goto</span> map_error_handling;<br>    &#125;<br>    <span class="hljs-built_in">array</span>[i].dma_addr = dma_addr;<br>    save_index++;<br>&#125;<br><br>...<br><br>map_error_handling:<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; save_index; i++) &#123;<br><br>    ...<br><br>    dma_unmap_single(<span class="hljs-built_in">array</span>[i].dma_addr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果在网卡驱动的 transmit 回调函数（例如 <code>ndo_start_xmit</code>）中出现了 DMA mapping 失败，那么驱动必须调用 <code>dev_kfree_skb()</code> 来释放 socket buffer 并返回<code>NETDEV_TX_OK</code> 。这表示这个 socket buffer 由于错误而丢弃掉了。</p>
<p>如果在 SCSI 驱动的 <code>queuecommand</code> 回调函数中出现了 DMA mapping 失败，那么驱动必须返回 <code>SCSI_MLQUEUE_HOST_BUSY</code> 。这意味着 SCSI 子系统稍后会再次重传该 command 给驱动。</p>
</li>
</ul>
<h4 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h4><p>在很多的平台上，<code>dma_unmap_&#123;single,page&#125;()</code> 其实什么也没有做，是空函数。因此，跟踪映射的 dma 地址及其长度基本上就是浪费内存空间。为了方便驱动工程师编写代码方便，我们提供了几个实用工具（宏定义），如果没有它们，驱动程序中将充分 <code>ifdef</code>或者类似的一些 “work around”。</p>
<p>下面我们并不是一个个的介绍这些宏定义，而是给出一些示例代码：</p>
<ul>
<li><p><code>DEFINE_DMA_UNMAP_&#123;ADDR,LEN&#125;</code>。在 DMA buffer 数据结构中使用这个宏定义，具体例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">before:<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ring_state</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *<span class="hljs-title">skb</span>;</span><br>    <span class="hljs-type">dma_addr_t</span> mapping;<br>    __u32 len;<br>&#125;;<br><br>after::<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ring_state</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *<span class="hljs-title">skb</span>;</span><br>    DEFINE_DMA_UNMAP_ADDR(mapping);<br>    DEFINE_DMA_UNMAP_LEN(len);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>根据 <code>CONFIG_NEED_DMA_MAP_STATE</code> 的配置不同，<code>DEFINE_DMA_UNMAP_&#123;ADDR,LEN&#125;</code>可能是定义相关的 dma 地址和长度的成员，也可能是空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NEED_DMA_MAP_STATE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_ADDR(ADDR_NAME)        dma_addr_t ADDR_NAME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_LEN(LEN_NAME)          __u32 LEN_NAME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr(PTR, ADDR_NAME)           ((PTR)-&gt;ADDR_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr_set(PTR, ADDR_NAME, VAL)  (((PTR)-&gt;ADDR_NAME) = (VAL))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len(PTR, LEN_NAME)             ((PTR)-&gt;LEN_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len_set(PTR, LEN_NAME, VAL)    (((PTR)-&gt;LEN_NAME) = (VAL))</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_ADDR(ADDR_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_LEN(LEN_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr(PTR, ADDR_NAME)           (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr_set(PTR, ADDR_NAME, VAL)  do &#123; &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len(PTR, LEN_NAME)             (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len_set(PTR, LEN_NAME, VAL)    do &#123; &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>dma_unmap_&#123;addr,len&#125;_set()</code> 来设置这些值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">before::<br><br>ringp-&gt;mapping = FOO;<br>ringp-&gt;len = BAR;<br><br>after::<br><br>dma_unmap_addr_set(ringp, mapping, FOO);<br>dma_unmap_len_set(ringp, len, BAR);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>dma_unmap_&#123;addr,len&#125;()</code> 来访问这些值</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">before::<br><br>dma_unmap_single(dev, ringp-&gt;mapping, ringp-&gt;len,<br>         DMA_FROM_DEVICE);<br><br>after::<br><br>dma_unmap_single(dev,<br>         dma_unmap_addr(ringp, mapping),<br>         dma_unmap_len(ringp, len),<br>         DMA_FROM_DEVICE);<br></code></pre></td></tr></table></figure>

<p>  上面的这些代码基本是不需要解释你就会明白的了。另外，我们对于 dma address 和 len 是分开处理的，因为在有些实现中，unmaping 的操作仅仅需要 dma address 信息就够了。</p>
<h4 id="平台问题"><a href="#平台问题" class="headerlink" title="平台问题"></a>平台问题</h4><p>如果你仅仅是驱动工程师，并不负责将 linux 迁移到某个 cpu arch上去，那么后面的内容其实你可以忽略了。</p>
<ul>
<li><p><code>Struct scatterlist</code> 的需求</p>
<p>如果处理器架构支持 IOMMU（包括软件模拟的 IOMMU），那么你需要打开 <code>CONFIG_NEED_SG_DMA_LENGTH</code> 这个内核选项</p>
</li>
<li><p>ARCH_DMA_MINALIGN</p>
<p>cpu 体系结构相关的代码必须要要保证 <code>kmalloc</code> 分配的 buffer 是 DMA-safe 的（<code>kmalloc</code> 分配的 buffer 也是有可能用于 DMA buffer），驱动和内核子系统的正确运行都是依赖这个条件的。如果一个处理器架构不是全面支持 DMA-coherent 的（例如硬件并不保证 cpu cache 中的数据等于 main memory 中的数据），那么必须定义<code>ARCH_DMA_MINALIGN</code>。而通过这个宏定义，<code>kmalloc </code>分配的 buffer 可以保证对齐在 ARCH_DMA_MINALIGN上，从而保证了 <code>kmalloc </code>分配的 DMA Buffer 不会和其他的 buffer 共享一个 cacheline。想要了解具体的实例可以参考 <code>arch/arm/include/asm/cache.h</code>。</p>
<p>另外，请注意：<code>ARCH_DMA_MINALIGN</code> 是 DMA buffer 的对齐约束，你不需要担心处理器架构的数据对齐约束（例如，有些处理器架构要求有些数据对象需要 64 位对齐）。</p>
</li>
</ul>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>如果没有无数个人的反馈和建议，本文档和 API 本身就不会有现在的形式。我们要特别提到以下几位人士，不分先后：</p>
<blockquote>
<p>Russell King <a href="mailto:&#x72;&#x6d;&#107;&#64;&#97;&#114;&#109;&#46;&#108;&#105;&#x6e;&#117;&#120;&#46;&#111;&#114;&#103;&#x2e;&#x75;&#107;">&#x72;&#x6d;&#107;&#64;&#97;&#114;&#109;&#46;&#108;&#105;&#x6e;&#117;&#120;&#46;&#111;&#114;&#103;&#x2e;&#x75;&#107;</a><br>Leo Dagum <a href="mailto:&#100;&#x61;&#103;&#117;&#109;&#64;&#98;&#97;&#114;&#114;&#x65;&#108;&#x2e;&#101;&#x6e;&#103;&#x72;&#46;&#x73;&#x67;&#105;&#46;&#x63;&#111;&#x6d;">&#100;&#x61;&#103;&#117;&#109;&#64;&#98;&#97;&#114;&#114;&#x65;&#108;&#x2e;&#101;&#x6e;&#103;&#x72;&#46;&#x73;&#x67;&#105;&#46;&#x63;&#111;&#x6d;</a><br>Ralf Baechle <a href="mailto:&#114;&#x61;&#x6c;&#102;&#64;&#111;&#115;&#115;&#x2e;&#115;&#x67;&#x69;&#x2e;&#99;&#111;&#x6d;">&#114;&#x61;&#x6c;&#102;&#64;&#111;&#115;&#115;&#x2e;&#115;&#x67;&#x69;&#x2e;&#99;&#111;&#x6d;</a><br>Grant Grundler <a href="mailto:&#103;&#x72;&#117;&#x6e;&#100;&#108;&#x65;&#114;&#x40;&#x63;&#117;&#112;&#46;&#x68;&#x70;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x72;&#117;&#x6e;&#100;&#108;&#x65;&#114;&#x40;&#x63;&#117;&#112;&#46;&#x68;&#x70;&#x2e;&#x63;&#x6f;&#109;</a><br>Jay Estabrook <a href="mailto:&#x4a;&#x61;&#x79;&#46;&#69;&#115;&#116;&#x61;&#x62;&#x72;&#111;&#111;&#107;&#x40;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x71;&#46;&#x63;&#111;&#109;">&#x4a;&#x61;&#x79;&#46;&#69;&#115;&#116;&#x61;&#x62;&#x72;&#111;&#111;&#107;&#x40;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x71;&#46;&#x63;&#111;&#109;</a><br>Thomas Sailer <a href="mailto:&#115;&#97;&#x69;&#x6c;&#x65;&#114;&#x40;&#105;&#102;&#x65;&#46;&#101;&#101;&#x2e;&#x65;&#x74;&#104;&#122;&#x2e;&#x63;&#104;">&#115;&#97;&#x69;&#x6c;&#x65;&#114;&#x40;&#105;&#102;&#x65;&#46;&#101;&#101;&#x2e;&#x65;&#x74;&#104;&#122;&#x2e;&#x63;&#104;</a><br>Andrea Arcangeli <a href="mailto:&#97;&#110;&#x64;&#114;&#x65;&#97;&#64;&#x73;&#117;&#x73;&#x65;&#x2e;&#100;&#x65;">&#97;&#110;&#x64;&#114;&#x65;&#97;&#64;&#x73;&#117;&#x73;&#x65;&#x2e;&#100;&#x65;</a><br>Jens Axboe <a href="mailto:&#x6a;&#x65;&#x6e;&#x73;&#x2e;&#97;&#x78;&#98;&#111;&#101;&#x40;&#111;&#114;&#x61;&#x63;&#x6c;&#x65;&#46;&#99;&#111;&#109;">&#x6a;&#x65;&#x6e;&#x73;&#x2e;&#97;&#x78;&#98;&#111;&#101;&#x40;&#111;&#114;&#x61;&#x63;&#x6c;&#x65;&#46;&#99;&#111;&#109;</a><br>David Mosberger-Tang <a href="mailto:&#100;&#x61;&#x76;&#105;&#x64;&#109;&#x40;&#x68;&#112;&#x6c;&#x2e;&#104;&#x70;&#x2e;&#x63;&#x6f;&#109;">&#100;&#x61;&#x76;&#105;&#x64;&#109;&#x40;&#x68;&#112;&#x6c;&#x2e;&#104;&#x70;&#x2e;&#x63;&#x6f;&#109;</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2023/10/08/linux/kernel/other/DMA/Dynamic DMA mapping Guide/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Gao Xiang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/08/linux/kernel/other/DMA/dma-mapping/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/08/linux/kernel/other/DMA/dma_buf/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://example.com/2023/10/08/linux/kernel/other/DMA/Dynamic%20DMA%20mapping%20Guide/';
          this.page.identifier = '/2023/10/08/linux/kernel/other/DMA/Dynamic%20DMA%20mapping%20Guide/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

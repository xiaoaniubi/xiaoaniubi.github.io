<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/08/linux/kernel/other/DMA/dma-mapping/"/>
    <url>/2023/10/08/linux/kernel/other/DMA/dma-mapping/</url>
    
    <content type="html"><![CDATA[<h1 id="dma-mapping-API-分析"><a href="#dma-mapping-API-分析" class="headerlink" title="dma-mapping API 分析"></a>dma-mapping API 分析</h1><span id="more"></span><h2 id="dma-alloc-coherent"><a href="#dma-alloc-coherent" class="headerlink" title="dma_alloc_coherent"></a>dma_alloc_coherent</h2><p><code>include/linux/dma-mapping.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dma_alloc_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">size_t</span> size, <span class="hljs-type">dma_addr_t</span> *dma_handle, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br><span class="hljs-keyword">return</span> dma_alloc_attrs(dev, size, dma_handle, gfp,<br>(gfp &amp; __GFP_NOWARN) ? DMA_ATTR_NO_WARN : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/08/linux/kernel/other/DMA/dma_buf/"/>
    <url>/2023/10/08/linux/kernel/other/DMA/dma_buf/</url>
    
    <content type="html"><![CDATA[<h1 id="DMA-BUF-框架"><a href="#DMA-BUF-框架" class="headerlink" title="DMA_BUF 框架"></a>DMA_BUF 框架</h1><span id="more"></span><h2 id="为什么要引入-dma-buf"><a href="#为什么要引入-dma-buf" class="headerlink" title="为什么要引入 dma_buf?"></a>为什么要引入 dma_buf?</h2><ul><li><p>之前的内核中缺少一个可以让不同设备、子系统之间进行内存共享的统一机制</p></li><li><p>在没有引入 <code>dma_buf</code> 之前内核中不同设备、子系统之间共享数据的方式是什么？</p><ul><li>各个 soc 厂商驱动、各种框架和子系统各自实现自己的机制</li></ul></li><li><p>引入后的优势：</p><ul><li><strong>设备间数据共享：</strong> <code>dma_buf</code> 主要设计用于在不同设备之间进行零拷贝数据共享。它提供了一个通用的接口，允许多个设备（例如 GPU、视频编解码器等）直接共享相同的内存缓冲区。这对于多媒体处理、图形渲染和硬件加速等应用非常有用，因为它们通常需要高性能的设备间数据传输。</li><li><strong>性能和效率：</strong> <code>dma_buf</code> 提供了高效的机制来管理和传输数据，避免了额外的数据复制和内存映射开销。这使得它在处理大量数据或对性能要求严格的应用中非常有优势。</li><li><strong>安全性和隔离性：</strong> <code>dma_buf</code> 具有安全性和隔离性优势，因为它提供了严格的访问控制和权限管理。这对于多个设备之间的数据共享和保护敏感数据非常有用。</li><li><strong>硬件加速器支持：</strong> 许多硬件加速器（如 GPU）支持 <code>dma_buf</code> 接口，这使得将数据传输到这些加速器变得更加容易。这允许在 GPU 和其他设备之间实现高性能的零拷贝数据传输。</li><li><strong>标准化接口：</strong> <code>dma_buf</code> 提供了标准化的接口和 API，使不同设备和驱动程序之间的集成更加容易。这有助于开发者更方便地实现设备间数据传输。</li></ul></li></ul><h2 id="dma-buf-实现"><a href="#dma-buf-实现" class="headerlink" title="dma_buf 实现"></a>dma_buf 实现</h2><p><code>dma-buf</code> 的出现主要为了解决各个驱动之间 buffer 共享的问题，其实它本质上是 buffer 与 file 的结合，即 <code>dma-buf</code> 既是物理 <strong>buffer</strong>，又是 <strong>file</strong>。buffer 是内容，file 是媒介，只有通过 file 这个媒介才能实现同一 buffer 在不同驱动之间的流转。</p><p>一个典型的应用框图</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309251800654.png" alt="img"></p><p>从角色来看：</p><ul><li><p><code>exporter</code>：</p><ul><li>分配自定义 buffer，然后将其设置到 <code>dma_buf</code> 中</li><li>产生与 <code>dma_buf</code> 关联的 fd，可通过 <code>ioctl</code> 传给应用层 <code>user</code></li></ul></li><li><p><code>user</code>：</p><ul><li>用户空间使用者</li><li>同时将 fd 传给所需的内核使用者</li></ul></li><li><p><code>importer</code>：</p><ul><li>内核空间使用者</li></ul></li></ul><p>从使用场景来看：</p><ul><li>用户空间和内核空间共享 <code>dma_buf</code></li><li>内核空间之间共享 <code>dma_buf</code></li></ul><p>为什么要使用 fd 呢？</p><ul><li>方便应用程序直接使用 <code>mmap</code> 访问该 buffer</li><li>方便该 buffer 在各个驱动模块之间流转，而无需拷贝</li><li>降低了各驱动之间的耦合度</li></ul><h3 id="exporter"><a href="#exporter" class="headerlink" title="exporter"></a>exporter</h3><p>在 <code>drivers/gpu/drm/i915/selftests/mock_dmabuf.c</code> 基础上稍加工，改成了一个较简单的 <code>dma_buf</code> <code>exporter</code> 例子，我们来看一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright © 2016 Intel Corporation</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Permission is hereby granted, free of charge, to any person obtaining a</span><br><span class="hljs-comment"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span><br><span class="hljs-comment"> * to deal in the Software without restriction, including without limitation</span><br><span class="hljs-comment"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span><br><span class="hljs-comment"> * and/or sell copies of the Software, and to permit persons to whom the</span><br><span class="hljs-comment"> * Software is furnished to do so, subject to the following conditions:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The above copyright notice and this permission notice (including the next</span><br><span class="hljs-comment"> * paragraph) shall be included in all copies or substantial portions of the</span><br><span class="hljs-comment"> * Software.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="hljs-comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="hljs-comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span><br><span class="hljs-comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="hljs-comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span><br><span class="hljs-comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span><br><span class="hljs-comment"> * IN THE SOFTWARE.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mock_dmabuf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/slab.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/highmem.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/miscdevice.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/module.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf</span> *<span class="hljs-title">g_dmabuf</span>;</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mock_dmabuf_begin_cpu_access</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf,</span><br><span class="hljs-params">      <span class="hljs-keyword">enum</span> dma_data_direction dir)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_attachment</span> *<span class="hljs-title">attachment</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> *<span class="hljs-title">sg_table</span>;</span><br><br><span class="hljs-keyword">if</span> (list_empty(&amp;dmabuf-&gt;attachments))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>attachment = list_first_entry(&amp;dmabuf-&gt;attachments, <span class="hljs-keyword">struct</span> dma_buf_attachment, node);<br>sg_table = attachment-&gt;priv;<br><br>dma_sync_sg_for_cpu(<span class="hljs-literal">NULL</span>, sg_table-&gt;sgl, sg_table-&gt;nents, dir);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mock_dmabuf_end_cpu_access</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf,</span><br><span class="hljs-params"><span class="hljs-keyword">enum</span> dma_data_direction dir)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_attachment</span> *<span class="hljs-title">attachment</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> *<span class="hljs-title">sg_table</span>;</span><br><br><span class="hljs-keyword">if</span> (list_empty(&amp;dmabuf-&gt;attachments))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>attachment = list_first_entry(&amp;dmabuf-&gt;attachments, <span class="hljs-keyword">struct</span> dma_buf_attachment, node);<br>sg_table = attachment-&gt;priv;<br>dma_sync_sg_for_device(<span class="hljs-literal">NULL</span>, sg_table-&gt;sgl, sg_table-&gt;nents, dir);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mock_dmabuf_attach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-keyword">struct</span> dma_buf_attachment *attachment)</span><br>&#123;<br>pr_info(<span class="hljs-string">&quot;dmabuf attach device: %s\n&quot;</span>, dev_name(attachment-&gt;dev));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mock_dmabuf_detach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-keyword">struct</span> dma_buf_attachment *attachment)</span><br>&#123;<br>pr_info(<span class="hljs-string">&quot;dmabuf detach device: %s\n&quot;</span>, dev_name(attachment-&gt;dev));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> sg_table *<span class="hljs-title function_">mock_map_dma_buf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf_attachment *attachment,</span><br><span class="hljs-params"> <span class="hljs-keyword">enum</span> dma_data_direction dir)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(attachment-&gt;dmabuf);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> *<span class="hljs-title">st</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scatterlist</span> *<span class="hljs-title">sg</span>;</span><br><span class="hljs-type">int</span> i, err;<br><br>st = kmalloc(<span class="hljs-keyword">sizeof</span>(*st), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!st)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>err = sg_alloc_table(st, mock-&gt;npages, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> err_free;<br><br>sg = st-&gt;sgl;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mock-&gt;npages; i++) &#123;<br>sg_set_page(sg, mock-&gt;pages[i], PAGE_SIZE, <span class="hljs-number">0</span>);<br>sg = sg_next(sg);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!dma_map_sg(attachment-&gt;dev, st-&gt;sgl, st-&gt;nents, dir)) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">goto</span> err_st;<br>&#125;<br><br><span class="hljs-keyword">return</span> st;<br><br>err_st:<br>sg_free_table(st);<br>err_free:<br>kfree(st);<br><span class="hljs-keyword">return</span> ERR_PTR(err);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mock_unmap_dma_buf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf_attachment *attachment,</span><br><span class="hljs-params">       <span class="hljs-keyword">struct</span> sg_table *st,</span><br><span class="hljs-params">       <span class="hljs-keyword">enum</span> dma_data_direction dir)</span><br>&#123;<br>dma_unmap_sg(attachment-&gt;dev, st-&gt;sgl, st-&gt;nents, dir);<br>sg_free_table(st);<br>kfree(st);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mock_dmabuf_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mock-&gt;npages; i++)<br>put_page(mock-&gt;pages[i]);<br><br>kfree(mock);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">mock_dmabuf_vmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><br><span class="hljs-keyword">return</span> vm_map_ram(mock-&gt;pages, mock-&gt;npages, <span class="hljs-number">0</span>, PAGE_KERNEL);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mock_dmabuf_vunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-type">void</span> *vaddr)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><br>vm_unmap_ram(vaddr, mock-&gt;npages);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">mock_dmabuf_kmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_num)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><br><span class="hljs-keyword">return</span> kmap(mock-&gt;pages[page_num]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mock_dmabuf_kunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_num, <span class="hljs-type">void</span> *addr)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><br><span class="hljs-keyword">return</span> kunmap(mock-&gt;pages[page_num]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mock_dmabuf_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br>    <br><span class="hljs-keyword">return</span> remap_pfn_range(vma, vma-&gt;vm_start, page_to_pfn(mock-&gt;pages[vma-&gt;vm_pgoff]),<br>PAGE_SIZE, vma-&gt;vm_page_prot);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_ops</span> <span class="hljs-title">mock_dmabuf_ops</span> =</span>  &#123;<br>.begin_cpu_access = mock_dmabuf_begin_cpu_access,<br>.end_cpu_access = mock_dmabuf_end_cpu_access,<br>.attach = mock_dmabuf_attach,<br>.detach = mock_dmabuf_detach,<br>.map_dma_buf = mock_map_dma_buf,<br>.unmap_dma_buf = mock_unmap_dma_buf,<br>.release = mock_dmabuf_release,<br>.<span class="hljs-built_in">map</span> = mock_dmabuf_kmap,<br>.unmap = mock_dmabuf_kunmap,<br>.mmap = mock_dmabuf_mmap,<br>.vmap = mock_dmabuf_vmap,<br>.vunmap = mock_dmabuf_vunmap,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dma_buf *<span class="hljs-title function_">mock_dmabuf</span><span class="hljs-params">(<span class="hljs-type">int</span> npages)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span>;</span><br>DEFINE_DMA_BUF_EXPORT_INFO(exp_info);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf</span> *<span class="hljs-title">dmabuf</span>;</span><br><span class="hljs-type">int</span> i;<br><br>mock = kmalloc(<span class="hljs-keyword">sizeof</span>(*mock) + npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> page *),<br>       GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!mock)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>mock-&gt;npages = npages;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<br>mock-&gt;pages[i] = alloc_page(GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!mock-&gt;pages[i])<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><br>exp_info.ops = &amp;mock_dmabuf_ops;<br>exp_info.size = npages * PAGE_SIZE;<br>exp_info.flags = O_CLOEXEC;<br>exp_info.priv = mock;<br><br>dmabuf = dma_buf_export(&amp;exp_info);<br><span class="hljs-keyword">if</span> (IS_ERR(dmabuf))<br><span class="hljs-keyword">goto</span> err;<br><br><span class="hljs-keyword">return</span> dmabuf;<br><br>err:<br><span class="hljs-keyword">while</span> (i--)<br>put_page(mock-&gt;pages[i]);<br>kfree(mock);<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mock_dmabuf_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-type">int</span> fd = dma_buf_fd(g_dmabuf, O_CLOEXEC);<br><br><span class="hljs-keyword">if</span> (copy_to_user((<span class="hljs-type">int</span> __user *)arg, &amp;fd, <span class="hljs-keyword">sizeof</span>(fd)))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">mock_dmabuf_fops</span> =</span> &#123;<br>.owner   = THIS_MODULE,<br>.unlocked_ioctl   = mock_dmabuf_ioctl,<br>&#125;;<br> <br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscdevice</span> <span class="hljs-title">mdev</span> =</span> &#123;<br>.minor = MISC_DYNAMIC_MINOR,<br>.name = <span class="hljs-string">&quot;mock_dmabuf&quot;</span>,<br>.fops = &amp;mock_dmabuf_fops,<br>&#125;;<br> <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">mock_dmabuf_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>g_dmabuf = mock_dmabuf(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> misc_register(&amp;mdev);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">mock_dmabuf_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>misc_deregister(&amp;mdev);<br>dma_buf_put(g_dmabuf);<br>&#125;<br><br>module_init(mock_dmabuf_init);<br>module_exit(mock_dmabuf_exit);<br><br>MODULE_AUTHOR(<span class="hljs-string">&quot;xiaoa&quot;</span>);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="初始化-dma-buf"><a href="#初始化-dma-buf" class="headerlink" title="初始化 dma_buf"></a>初始化 dma_buf</h4><ul><li><p>初始化自定义的数据结构 <code>mock_dmabuf</code>，见<code>drivers/gpu/drm/i915/selftests/mock_dmabuf.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> &#123;</span><br><span class="hljs-type">int</span> npages;<span class="hljs-comment">// 共享 buf 有多少个页</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">pages</span>[];</span><span class="hljs-comment">// 指向真正分配的物理页面，后面可通过 page 转换为物理地址或 dma 地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>kmalloc</code> 分配 <code>mock_dmabuf</code> </li><li>为每一个 page 分配物理页面，我们这里只分配了 1 个页面</li></ul></li><li><p>初始化 <code>dma_buf_export_info</code>，并设置与 <code>dma_buf</code> 相关的信息，如 <code>mock_dmabuf</code> ，因为最后会使用它来得到 <code>dma_buf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct dma_buf_export_info - holds information needed to export a dma_buf</span><br><span class="hljs-comment"> * @exp_name:name of the exporter - useful for debugging.</span><br><span class="hljs-comment"> * @owner:pointer to exporter module - used for refcounting kernel module</span><br><span class="hljs-comment"> * @ops:Attach allocator-defined dma buf ops to the new buffer</span><br><span class="hljs-comment"> * @size:Size of the buffer</span><br><span class="hljs-comment"> * @flags:mode flags for the file</span><br><span class="hljs-comment"> * @resv:reservation-object, NULL to allocate default one</span><br><span class="hljs-comment"> * @priv:Attach private data of allocator to this buffer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This structure holds the information required to export the buffer. Used</span><br><span class="hljs-comment"> * with dma_buf_export() only.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_export_info</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *exp_name;<span class="hljs-comment">// exporter 名字，可用于调试</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_ops</span> *<span class="hljs-title">ops</span>;</span><span class="hljs-comment">// 对 dma_buf 的操作函数集</span><br><span class="hljs-type">size_t</span> size;<span class="hljs-comment">// dma_buf 的大小</span><br><span class="hljs-type">int</span> flags;<span class="hljs-comment">// 关联的 file 的模式标志</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reservation_object</span> *<span class="hljs-title">resv</span>;</span><br><span class="hljs-type">void</span> *priv;<span class="hljs-comment">// 一般用于存放我们自定义的数据结构</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DEFINE_DMA_BUF_EXPORT_INFO - helper macro for exporters</span><br><span class="hljs-comment"> * @name: export-info name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * DEFINE_DMA_BUF_EXPORT_INFO macro defines the &amp;struct dma_buf_export_info,</span><br><span class="hljs-comment"> * zeroes it out and pre-populates exp_name in it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_BUF_EXPORT_INFO(name)\</span><br><span class="hljs-meta">struct dma_buf_export_info name = &#123; .exp_name = KBUILD_MODNAME, \</span><br><span class="hljs-meta"> .owner = THIS_MODULE &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">exp_info.ops = &amp;mock_dmabuf_ops;<span class="hljs-comment">// dma_buf 的操作函数集</span><br>exp_info.size = npages * PAGE_SIZE;<span class="hljs-comment">// 我们只用 1 个页面，所以大小就是 1 x PAGE_SIZE</span><br>exp_info.flags = O_CLOEXEC;<br>exp_info.priv = mock;<span class="hljs-comment">// 私有数据结构存放了我们自定义的数据结构 mock</span><br></code></pre></td></tr></table></figure></li><li><p>调用 <code>dma_buf_export</code> 得到 <code>dma_buf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dma_buf *<span class="hljs-title function_">dma_buf_export</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> dma_buf_export_info *exp_info)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf</span> *<span class="hljs-title">dmabuf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br><span class="hljs-type">size_t</span> alloc_size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> dma_buf);<br><span class="hljs-type">int</span> ret;<br>...<br>        <br>    <span class="hljs-comment">// 分配 dma_buf</span><br>dmabuf = kzalloc(alloc_size, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!dmabuf) &#123;<br>ret = -ENOMEM;<br><span class="hljs-keyword">goto</span> err_module;<br>&#125;<br><br>    <span class="hljs-comment">// 设置 dma_buf</span><br>dmabuf-&gt;priv = exp_info-&gt;priv;<br>dmabuf-&gt;ops = exp_info-&gt;ops;<br>dmabuf-&gt;size = exp_info-&gt;size;<br>dmabuf-&gt;exp_name = exp_info-&gt;exp_name;<br>dmabuf-&gt;owner = exp_info-&gt;owner;<br>...<br>    <br>    <span class="hljs-comment">// 分配 file</span><br>file = anon_inode_getfile(<span class="hljs-string">&quot;dmabuf&quot;</span>, &amp;dma_buf_fops, dmabuf,<br>exp_info-&gt;flags);<br>file-&gt;f_mode |= FMODE_LSEEK;<br>    <span class="hljs-comment">// dma_buf 和 file 相关联</span><br>dmabuf-&gt;file = file;<br><br>mutex_init(&amp;dmabuf-&gt;lock);<br>INIT_LIST_HEAD(&amp;dmabuf-&gt;attachments);<br><br>mutex_lock(&amp;db_list.lock);<br>list_add(&amp;dmabuf-&gt;list_node, &amp;db_list.head);<br>mutex_unlock(&amp;db_list.lock);<br><br><span class="hljs-keyword">return</span> dmabuf;<br><br>err_dmabuf:<br>kfree(dmabuf);<br>err_module:<br>module_put(exp_info-&gt;owner);<br><span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要做的事情有：</p><ul><li><p>分配并设置<code>dma_buf</code> 数据结构</p></li><li><p>调用 <code>anon_inode_getfile</code> 分配一个匿名文件，<code>file</code>、<code>inode</code>、<code>dentry</code> 都是假的，并已关联，其中 <code>inode</code> 为全局变量 <code>anon_inode_inode</code>，是 anon_inodefs 文件系统初始化时就创建好的，所有有这样需求的内核模块都可以使用它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">file = anon_inode_getfile(<span class="hljs-string">&quot;dmabuf&quot;</span>, &amp;dma_buf_fops, dmabuf,exp_info-&gt;flags);<br>    alloc_file_pseudo<br>        path.dentry = d_alloc_pseudo(mnt-&gt;mnt_sb, &amp;this);<span class="hljs-comment">// 分配假的 dentry 结构</span><br>        d_instantiate(path.dentry, inode);<span class="hljs-comment">// dentry 和 inode 关联</span><br>        file = alloc_file(&amp;path, flags, fops);<span class="hljs-comment">// 分配 file</span><br>    file-&gt;private_data = priv;<span class="hljs-comment">// dma_buf</span><br></code></pre></td></tr></table></figure></li><li><p><code>dma_buf</code> 和 <code>file</code> 关联，<code>dma_buf</code> 在 <code>anon_inode_getfile</code> 中设置到了 <code>file-&gt;private_data</code> 中</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">dmabuf-&gt;file <span class="hljs-operator">=</span> file<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>将 <code>dma_buf</code> 加入全局 <code>dma_buf</code>  链表中，用于管理</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-keyword">struct</span> dma_buf_list db_list;<br><br><span class="hljs-built_in">list</span><span class="hljs-constructor">_add(&amp;<span class="hljs-params">dmabuf</span>-&gt;<span class="hljs-params">list_node</span>, &amp;<span class="hljs-params">db_list</span>.<span class="hljs-params">head</span>)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>至此 <code>dma_buf</code> 已分配好，并且与 <code>file</code> 结构关联，但是 <code>file</code> 还没有和 <code>fd</code> 关联</p><h4 id="关联-fd"><a href="#关联-fd" class="headerlink" title="关联 fd"></a>关联 fd</h4><p>在 <code>mock_dmabuf_ioctl</code> 中调用 <code>dma_buf_fd</code> 关联 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mock_dmabuf_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-type">int</span> fd = dma_buf_fd(g_dmabuf, O_CLOEXEC);<br><br><span class="hljs-keyword">if</span> (copy_to_user((<span class="hljs-type">int</span> __user *)arg, &amp;fd, <span class="hljs-keyword">sizeof</span>(fd)))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>drivers/dma-buf/dma-buf.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dma_buf_fd - returns a file descriptor for the given dma_buf</span><br><span class="hljs-comment"> * @dmabuf:[in]pointer to dma_buf for which fd is required.</span><br><span class="hljs-comment"> * @flags:      [in]    flags to give to fd</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * On success, returns an associated &#x27;fd&#x27;. Else, returns error.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dma_buf_fd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-type">int</span> fd;<br><br><span class="hljs-keyword">if</span> (!dmabuf || !dmabuf-&gt;file)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>fd = get_unused_fd_flags(flags);<br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> fd;<br><br>fd_install(fd, dmabuf-&gt;file);<br><br><span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>分配 <code>fd</code>，并且和<code>file</code> 关联，相当于 <code>open</code> 了文件</li></ul><p>因为要传到应用层，所以放到了 <code>ioctl</code> 中，等用户来获取，然后用户就可以调用 <code>mmap</code> 映射自己用或将 <code>fd</code> 传给内核空间使用者了</p><p>但是 fd 是进程专有的资源，相同的 fd 在不同的进程是指向不同的文件的，那怎么解决跨进程问题的呢？</p><ul><li><p>Linux：使用 <code>socket</code> 进程间通信，如<code>sendmsg</code>，协议必须是 <code>AF_UNIX</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">SCM_RIGHTS<br>      Send or receive a <span class="hljs-built_in">set</span> of open file descriptors from another process.  The data portion contains an integer <span class="hljs-built_in">array</span> of the file descriptors.<br><br>      Commonly,  this  operation  is referred to as <span class="hljs-string">&quot;passing a file descriptor&quot;</span> to another process.  However, more accurately, what is being passed is a reference to an open file <span class="hljs-title function_">description</span> <span class="hljs-params">(see open(<span class="hljs-number">2</span>))</span>, and in the receiving process it is likely that a different file descriptor number will be used.  Semantically, this operation is equiv‐ alent to <span class="hljs-title function_">duplicating</span> <span class="hljs-params">(dup(<span class="hljs-number">2</span>))</span> a file descriptor into the file descriptor table of another process.<br></code></pre></td></tr></table></figure></li><li><p>Android: 使用 binder 机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">binder_transaction</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_thread *thread,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_transaction_data *tr, <span class="hljs-type">int</span> reply)</span><br>&#123;<br><span class="hljs-keyword">case</span> BINDER_TYPE_FD: &#123;<br>        <span class="hljs-type">int</span> target_fd;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>        file = fget(fp-&gt;handle);<span class="hljs-comment">// 获取 file 结构</span><br>        target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC); <span class="hljs-comment">// 在目标进程中创建一个 fd</span><br>        task_fd_install(target_proc, target_fd, file); <span class="hljs-comment">// fd 和 file 关联</span><br>        ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>以上两种方式并不是将相同的 fd 传递给目标进程，而是在目标进程中 <code>dup</code> 一个新的 fd，并指向相同的 file</p><h4 id="操作函数集"><a href="#操作函数集" class="headerlink" title="操作函数集"></a>操作函数集</h4><p>内核使用者拿到 fd 后，会得到 <code>dma_buf</code>，然后就可以对 buf 进行读写操作了，但是在读写前后要做一些事情，比如内存映射、解除映射等操作，<code>importer</code> 会调用 <code>dma_buf</code> 核心层 API，然后再调用到我们的<code>dma_buf_ops</code> 的函数，如 <code>mock_dmabuf_ops</code></p><h5 id="内核软件访问-API"><a href="#内核软件访问-API" class="headerlink" title="内核软件访问 API"></a>内核软件访问 API</h5><p><code>dma_buf</code> 不仅仅只给硬件 dma 使用，cpu 软件访问也可以，这也是 <code>dma_buf</code> 更加受欢迎的地方，下面的 API 实现了 cpu 在内核空间对 <code>dma-buf</code> 内存的访问：</p><ul><li><p><code>dma_buf_vmap/dma_buf_vunmap</code>：会调用 <code>mock_dmabuf_vmap/mock_dmabuf_vunmap</code>，一次映射多个 page，且这些 page 可以物理不连续，只能在进程上下文中调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">dma_buf_vmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf)</span><br>&#123;<br><span class="hljs-type">void</span> *ptr;<br>...<br>    mutex_lock(&amp;dmabuf-&gt;lock);<br>ptr = dmabuf-&gt;ops-&gt;vmap(dmabuf);<br>...<br>dmabuf-&gt;vmap_ptr = ptr;<br>dmabuf-&gt;vmapping_counter = <span class="hljs-number">1</span>;<br>    mutex_unlock(&amp;dmabuf-&gt;lock);<br><br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dma_buf_vunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-type">void</span> *vaddr)</span><br>&#123;<br>...<br>mutex_lock(&amp;dmabuf-&gt;lock);<br><span class="hljs-keyword">if</span> (--dmabuf-&gt;vmapping_counter == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dmabuf-&gt;ops-&gt;vunmap)<br>dmabuf-&gt;ops-&gt;vunmap(dmabuf, vaddr);<br>dmabuf-&gt;vmap_ptr = <span class="hljs-literal">NULL</span>;<br>&#125;<br>mutex_unlock(&amp;dmabuf-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">mock_dmabuf_vmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><span class="hljs-keyword">return</span> vm_map_ram(mock-&gt;pages, mock-&gt;npages, <span class="hljs-number">0</span>, PAGE_KERNEL);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mock_dmabuf_vunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-type">void</span> *vaddr)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br>vm_unmap_ram(vaddr, mock-&gt;npages);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>dma_buf_kmap/dma_buf_kunmap</code>：会调用 <code>mock_dmabuf_kmap/mock_dmabuf_kunmap</code>，一次只能映射一页，只能在进程上下文中调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">dma_buf_kmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_num)</span><br>&#123;<br><span class="hljs-keyword">if</span> (!dmabuf-&gt;ops-&gt;<span class="hljs-built_in">map</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> dmabuf-&gt;ops-&gt;<span class="hljs-built_in">map</span>(dmabuf, page_num);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dma_buf_kunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_num,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *vaddr)</span><br>&#123;<br><span class="hljs-keyword">if</span> (dmabuf-&gt;ops-&gt;unmap)<br>dmabuf-&gt;ops-&gt;unmap(dmabuf, page_num, vaddr);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">mock_dmabuf_kmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_num)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><span class="hljs-keyword">return</span> kmap(mock-&gt;pages[page_num]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mock_dmabuf_kunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_num, <span class="hljs-type">void</span> *addr)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><span class="hljs-keyword">return</span> kunmap(mock-&gt;pages[page_num]);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>kmap</code> 或 <code>vmap</code>操作后，就可以把实际的物理内存映射到内核空间，转化成 cpu 可以连续访问的虚拟地址，方便以后直接读写这块物理内存。</p></li></ul><h5 id="应用软件访问-API"><a href="#应用软件访问-API" class="headerlink" title="应用软件访问 API"></a>应用软件访问 API</h5><p>应用层拿到 <code>dma_buf</code> 的 fd 后就可以调用 <code>mmap</code> 直接映射读写了</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309261520035.png" alt="在这里插入图片描述"></p><ul><li><p><code>dma_buf_mmap</code>：会调用 <code>mock_dmabuf_mmap</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dma_buf_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff)</span><br>&#123;<br>...<br>ret = dmabuf-&gt;ops-&gt;mmap(dmabuf, vma);<br>...<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mock_dmabuf_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dma_buf, <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(dma_buf);<br><span class="hljs-keyword">return</span> remap_pfn_range(vma, vma-&gt;vm_start, page_to_pfn(mock-&gt;pages[vma-&gt;vm_pgoff]),<br>PAGE_SIZE, vma-&gt;vm_page_prot);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="DMA-硬件访问-API"><a href="#DMA-硬件访问-API" class="headerlink" title="DMA 硬件访问 API"></a>DMA 硬件访问 API</h5><p><code>dma-buf</code> 设计之初就是为满足那些大内存访问需求的硬件而设计的，如 GPU&#x2F;DPU。因此，<code>dma-buf</code> 在内核中出现频率最高的就是下面的接口：</p><ul><li><p><code>dma_buf_attach/dma_buf_detach</code> ：会调用 <code>mock_dmabuf_attach/mock_dmabuf_detach </code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dma_buf_attachment *<span class="hljs-title function_">dma_buf_attach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_attachment</span> *<span class="hljs-title">attach</span>;</span><br><span class="hljs-type">int</span> ret;<br>...<br><br>attach = kzalloc(<span class="hljs-keyword">sizeof</span>(*attach), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!attach)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>attach-&gt;dev = dev;<br>attach-&gt;dmabuf = dmabuf;<br><br>mutex_lock(&amp;dmabuf-&gt;lock);<br><br><span class="hljs-keyword">if</span> (dmabuf-&gt;ops-&gt;attach) &#123;<br>ret = dmabuf-&gt;ops-&gt;attach(dmabuf, attach);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> err_attach;<br>&#125;<br>list_add(&amp;attach-&gt;node, &amp;dmabuf-&gt;attachments);<br><br>mutex_unlock(&amp;dmabuf-&gt;lock);<br><span class="hljs-keyword">return</span> attach;<br><br>err_attach:<br>kfree(attach);<br>mutex_unlock(&amp;dmabuf-&gt;lock);<br><span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dma_buf_detach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf, <span class="hljs-keyword">struct</span> dma_buf_attachment *attach)</span><br>&#123;<br><span class="hljs-keyword">if</span> (WARN_ON(!dmabuf || !attach))<br><span class="hljs-keyword">return</span>;<br><br>mutex_lock(&amp;dmabuf-&gt;lock);<br>list_del(&amp;attach-&gt;node);<br><span class="hljs-keyword">if</span> (dmabuf-&gt;ops-&gt;detach)<br>dmabuf-&gt;ops-&gt;detach(dmabuf, attach);<br><br>mutex_unlock(&amp;dmabuf-&gt;lock);<br>kfree(attach);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>dma_buf_attach</code> 主要做的事情：<ul><li>分配一个 <code>dma_buf_attachment</code></li><li>调用 <code>mock_dmabuf_attach</code>，目前为空函数</li><li>将 device 和 <code>dmabuf</code> 都设置到 <code>dma_buf_attachment</code> 中，即<code>dma_buf</code> 和某一个设备绑定了，然后把这个绑定关系 <code>dma_buf_attachment</code> 链入 <code>dma_buf</code> 的 <code>attachments</code> 链表头上，也就是说把 <code>dma_buf</code> 的使用者管理起来</li></ul></li></ul></li><li><p><code>dma_buf_map_attachment/dma_buf_unmap_attachment</code>：会调用 <code>mock_map_dma_buf/mock_unmap_dma_buf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> sg_table *<span class="hljs-title function_">dma_buf_map_attachment</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf_attachment *attach,</span><br><span class="hljs-params"><span class="hljs-keyword">enum</span> dma_data_direction direction)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> *<span class="hljs-title">sg_table</span>;</span><br><br>might_sleep();<br><br><span class="hljs-keyword">if</span> (WARN_ON(!attach || !attach-&gt;dmabuf))<br><span class="hljs-keyword">return</span> ERR_PTR(-EINVAL);<br><br>sg_table = attach-&gt;dmabuf-&gt;ops-&gt;map_dma_buf(attach, direction);<br><span class="hljs-keyword">if</span> (!sg_table)<br>sg_table = ERR_PTR(-ENOMEM);<br><br><span class="hljs-keyword">return</span> sg_table;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dma_buf_unmap_attachment</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf_attachment *attach,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> sg_table *sg_table,</span><br><span class="hljs-params"><span class="hljs-keyword">enum</span> dma_data_direction direction)</span><br>&#123;<br>might_sleep();<br><br><span class="hljs-keyword">if</span> (WARN_ON(!attach || !attach-&gt;dmabuf || !sg_table))<br><span class="hljs-keyword">return</span>;<br><br>attach-&gt;dmabuf-&gt;ops-&gt;unmap_dma_buf(attach, sg_table,<br>direction);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>dma_buf_map_attachment</code> 主要做两件事：</p><ul><li><p>将 <code>dma_buf</code> 中的物理页面分别放到一个个 <code>scatterlist</code> 中，然后再链如 <code>sg_table</code> 中</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309261658939.png" alt="在这里插入图片描述"></p><ul><li><p><code>sg_table</code>：代表整个链表，由一块块单个物理连续的 buffer 所组成的链表，但从整体上看却是离散的（整体上可以连续或非连续），它是 <code>dma-buf</code> 供 DMA 硬件访问的终极目标，也是 DMA 硬件访问离散 memory 的唯一途径</p></li><li><p><code>scatterlist</code>：代表每一个链表项，就是上面一块块连续的 buf</p><p> 到了这里就说一下 DMA 的设置</p><ul><li><p>没有 IOMMU（SMMU）：DMA 控制器只能接收连续的物理地址</p></li><li><p>有 IOMMU（SMMU）：目前大多数 DMA 控制器都支持硬件的 SG DMA 模式，将 <code>sg_table</code> 设置到寄存器中，DMA 就可以自动遍历整个 <code>sg_table</code> 链表，将不连续的物理地址映射成连续 I&#x2F;O virtual address (IOVA)</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309261727844.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309261729338.png"></p></li></ul></li></ul><p></p></li><li><p>同步 cache，我们先来看一下 DMA 缓存一致性的问题</p><ul><li><p>cpu 写内存的时候有两种方式：</p><ul><li><code>write through</code>: cpu 直接写内存，不经过 cache。</li><li><code>write back</code>: cpu 只写到 cache 中。cache 的硬件使用 LRU 算法将 cache 里面的内容替换到内存。通常是这种方式。</li></ul></li><li><p>DMA 可以将内存中的数据直接搬移到外设。但 DMA 不能访问 cpu 的 cache，cpu 在读内存的时候，如果 cache 命中则只是读 cache，而不会读内存，写内存的时候，也可能没写到内存，而是直接写到了 cache。</p><p>所以如果 DMA 从将数据从外设写到内存，cpu 中 cache 中的数据（如果有的话）就是旧数据了，这时 cpu 在读内存的时候命中 cache了，就读到了旧数据；cpu 写数据到内存时，如果只是先写到了cache，则内存里的数据就是旧数据了。这两种情况（两个方向）都存在cache一致性问题</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309271031546.png"></p></li></ul><p>两个方向的操作：</p><ul><li><code>DMA To Device</code> ：cpu 写数据到 cache 中，而不是 DDR 中，导致 DMA 往 Device 写的数据不是最新的，所以需要将 cache 中的数据回写到 DDR 。</li><li><code>DMA From Device </code>：DMA 将 Device 中的数据存入 DDR 中，cpu 读的时候可能读的是 cache 中的旧数据，所以需要让 cache 无效，cpu 就可以从 DDR 中读取最新数据了</li></ul><p>通常我们使用如下流式 DMA 映射接口来完成 cache 的同步，我们只讲支持 SG DMA 模式的 DMA 控制器的函数 <code>dma_map_page() / dma_unmap_page()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_map_single() / dma_unmap_single()<br>dma_map_page() / dma_unmap_page()<br>dma_map_sg() / dma_unmap_sg()<br></code></pre></td></tr></table></figure></li></ul><p>我们来看一下 <code>mock_map_dma_buf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> sg_table *<span class="hljs-title function_">mock_map_dma_buf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf_attachment *attachment,</span><br><span class="hljs-params"> <span class="hljs-keyword">enum</span> dma_data_direction dir)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mock_dmabuf</span> *<span class="hljs-title">mock</span> =</span> to_mock(attachment-&gt;dmabuf);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> *<span class="hljs-title">st</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scatterlist</span> *<span class="hljs-title">sg</span>;</span><br><span class="hljs-type">int</span> i, err;<br><br>    <span class="hljs-comment">// 分配 sg_table</span><br>st = kmalloc(<span class="hljs-keyword">sizeof</span>(*st), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!st)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>    <span class="hljs-comment">// 分配 scatterlist</span><br>err = sg_alloc_table(st, mock-&gt;npages, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> err_free;<br><br>    <span class="hljs-comment">// 将物理页面设置到 scatterlist</span><br>sg = st-&gt;sgl;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mock-&gt;npages; i++) &#123;<br>sg_set_page(sg, mock-&gt;pages[i], PAGE_SIZE, <span class="hljs-number">0</span>);<br>sg = sg_next(sg);<br>&#125;<br><br>    <span class="hljs-comment">// 同步 cache</span><br><span class="hljs-keyword">if</span> (!dma_map_sg(attachment-&gt;dev, st-&gt;sgl, st-&gt;nents, dir)) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">goto</span> err_st;<br>&#125;<br><br><span class="hljs-keyword">return</span> st;<br><br>err_st:<br>sg_free_table(st);<br>err_free:<br>kfree(st);<br><span class="hljs-keyword">return</span> ERR_PTR(err);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>分配一个 <code>sg_table</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scatterlist</span> *<span class="hljs-title">sgl</span>;</span><span class="hljs-comment">// 指向 scatterlist 数组</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nents;<span class="hljs-comment">// scatterlist 数组长度，表示有几个 scatterlist</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_nents;<span class="hljs-comment">// scatterlist 原始长度，一般等于 nents</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>sg_alloc_table</code> 分配 <code>scatterlist</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scatterlist</span> &#123;</span><br>    <span class="hljs-comment">/* 记录该内存块所在的页面号，低两位特色，页面必须 4 字节对齐</span><br><span class="hljs-comment">     * bit[0] = 1，表示该节点是一个铰链，铰链是用于将多个链串成一个更大的链</span><br><span class="hljs-comment">     * bit[0] = 0，表示一个普通内存节点</span><br><span class="hljs-comment">     * bit[1] = 1，表示该节点是尾节点</span><br><span class="hljs-comment">     * bit[1] = 0，表示一个普通节点</span><br><span class="hljs-comment">    */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>page_link;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>offset;<span class="hljs-comment">// 内存块在页面内的偏移</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>length;<span class="hljs-comment">// 内存块长度</span><br><span class="hljs-type">dma_addr_t</span>dma_address;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Notes on SG table design.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * We use the unsigned long page_link field in the scatterlist struct to place</span><br><span class="hljs-comment"> * the page pointer AND encode information about the sg table as well. The two</span><br><span class="hljs-comment"> * lower bits are reserved for this information.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If bit 0 is set, then the page_link contains a pointer to the next sg</span><br><span class="hljs-comment"> * table list. Otherwise the next entry is at sg + 1.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If bit 1 is set, then this sg entry is the last element in a list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * See sg_next().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SG_CHAIN0x01UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SG_END0x02UL</span><br></code></pre></td></tr></table></figure><ul><li><code>nents</code> 表示要分配多少个 <code>scatterlist</code></li><li>调用 <code>sg_kmalloc</code> 分配 N 个 <code>scatterlist</code> 结构体大小内存<ul><li>如果大小小于 PAGE_SIZE，调用 <code>kmalloc_array</code> 分配</li><li>如果大小等于 PAGE_SIZE，直接调用 <code>alloc_page</code> 分配一页</li></ul></li><li>N 个 <code>scatterlist</code> 内存清理，然后调用<code>sg_mark_end</code>将数组的最后一个元素的<code>page_link</code>标记为尾节点</li><li>让 <code>sg_table</code> 指向 <code>scatterlist</code>，或者将多个页面的 <code>scatterlist</code> 连接起来</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sg_alloc_table</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sg_table *table, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nents, <span class="hljs-type">gfp_t</span> gfp_mask)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>ret = __sg_alloc_table(table, nents, SG_MAX_SINGLE_ALLOC,<br>       <span class="hljs-literal">NULL</span>, gfp_mask, sg_kmalloc);<br><span class="hljs-keyword">if</span> (unlikely(ret))<br>__sg_free_table(table, SG_MAX_SINGLE_ALLOC, <span class="hljs-literal">false</span>, sg_kfree);<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">int</span> __sg_alloc_table(<span class="hljs-keyword">struct</span> sg_table *table, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nents,<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_ents, <span class="hljs-keyword">struct</span> scatterlist *first_chunk,<br>     <span class="hljs-type">gfp_t</span> gfp_mask, sg_alloc_fn *alloc_fn)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scatterlist</span> *<span class="hljs-title">sg</span>, *<span class="hljs-title">prv</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left;<br><br><span class="hljs-built_in">memset</span>(table, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*table));<br>    ...<br>        <br>left = nents;<br>prv = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sg_size, alloc_size = left;<br><br><span class="hljs-keyword">if</span> (alloc_size &gt; max_ents) &#123;<br>alloc_size = max_ents;<br>sg_size = alloc_size - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span><br>sg_size = alloc_size;<br><br>left -= sg_size;<br><br><span class="hljs-keyword">if</span> (first_chunk) &#123;<br>sg = first_chunk;<br>first_chunk = <span class="hljs-literal">NULL</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 分配 alloc_size 的内存，可能包含多个 scatterlist</span><br>sg = alloc_fn(alloc_size, gfp_mask);<br>&#125;<br><span class="hljs-keyword">if</span> (unlikely(!sg)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adjust entry count to reflect that the last</span><br><span class="hljs-comment"> * entry of the previous table won&#x27;t be used for</span><br><span class="hljs-comment"> * linkage.  Without this, sg_kfree() may get</span><br><span class="hljs-comment"> * confused.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (prv)<br>table-&gt;nents = ++table-&gt;orig_nents;<br><br> <span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br>        <span class="hljs-comment">/* 1. scatterlist 内存清理</span><br><span class="hljs-comment">         * 2. 设置最后一个元素的 page_link 标记为尾节点</span><br><span class="hljs-comment">         */</span><br>sg_init_table(sg, alloc_size);<br>table-&gt;nents = table-&gt;orig_nents += sg_size;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If this is the first mapping, assign the sg table header.</span><br><span class="hljs-comment"> * If this is not the first mapping, chain previous part.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (prv)<br>sg_chain(prv, max_ents, sg);<br><span class="hljs-keyword">else</span><br>table-&gt;sgl = sg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If no more entries after this one, mark the end</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!left)<br>sg_mark_end(&amp;sg[sg_size - <span class="hljs-number">1</span>]);<br><br>prv = sg;<br>&#125; <span class="hljs-keyword">while</span> (left);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309262003762.png" alt="image-20230926200307313"></p></li><li><p>调用 <code>sg_set_page</code> 将每个 <code>scatterlist</code> 指向真正的物理页面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sg_set_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> scatterlist *sg, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params">       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset)</span><br>&#123;<br>sg_assign_page(sg, page);<br>sg-&gt;offset = offset;<br>sg-&gt;length = len;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sg_assign_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> scatterlist *sg, <span class="hljs-keyword">struct</span> page *page)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_link = sg-&gt;page_link &amp; (SG_CHAIN | SG_END);<br>sg-&gt;page_link = page_link | (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) page;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> scatterlist *<span class="hljs-title function_">sg_next</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> scatterlist *sg)</span><br>&#123;<br><span class="hljs-keyword">if</span> (sg_is_last(sg))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>sg++;<br><span class="hljs-keyword">if</span> (unlikely(sg_is_chain(sg)))<br>sg = sg_chain_ptr(sg);<br><br><span class="hljs-keyword">return</span> sg;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>dma_map_sg</code> 有两件事：</p><ul><li>同步 cache，我们传的 DMA 方向是双向 <code>DMA_BIDIRECTIONAL</code>，最终调用的是 <code>__dma_clean_area</code>，意思是在让 DMA 使用这块 buf 之前，要先将 <code>sg_table</code> 里所有的物理内存对应的 cache 都 flush 到内存中，保证 DMA 拿到的数据是最新的</li><li>得到 dma 地址，设置到每个 <code>scatterlist</code> 里</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dma_map_sg<br>dma_map_sg_attrs<br>dma_direct_map_sg<br>sg-&gt;dma_address = dma_direct_map_page(dev, sg_page(sg), sg-&gt;offset, sg-&gt;length, dir, attrs)<br>arch_sync_dma_for_device<br>__dma_map_area<br>    __dma_clean_area<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs asm">/*<br> *__dma_map_area(start, size, dir)<br> *- start- kernel virtual start address<br> *- size- size of region<br> *- dir- DMA direction<br> */<br>ENTRY(__dma_map_area)<br>cmpw2, #DMA_FROM_DEVICE<br>b.eq__dma_inv_area<br>b__dma_clean_area<br>ENDPIPROC(__dma_map_area)<br><br>/*<br> *__dma_inv_area(start, size)<br> *- start   - virtual start address of region<br> *- size    - size in question<br> */<br>__dma_inv_area:<br>addx1, x1, x0<br>dcache_line_size x2, x3<br>subx3, x2, #1<br>tstx1, x3// end cache line aligned?<br>bicx1, x1, x3<br>b.eq1f<br>dccivac, x1// clean &amp; invalidate D / U line<br>1:tstx0, x3// start cache line aligned?<br>bicx0, x0, x3<br>b.eq2f<br>dccivac, x0// clean &amp; invalidate D / U line<br>b3f<br>2:dcivac, x0// invalidate D / U line<br>3:addx0, x0, x2<br>cmpx0, x1<br>b.lo2b<br>dsbsy<br>ret<br></code></pre></td></tr></table></figure><p>在 DMA 操作完内存后需要调用 <code>dma_unmap_sg</code> 来同步 cache，最终调用的是 <code>__dma_inv_area</code>，意思是将 <code>sg_table</code> 里的所有物理内存对应的 cache 全部无效，然后 cpu 读的时候就会直接去内存读取最新的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">dma_unmap_sg<br>dma_unmap_sg_attrs<br>dma_direct_unmap_sg<br>dma_direct_unmap_page<br>dma_direct_sync_single_for_cpu(dev, addr, size, dir)<br>arch_sync_dma_for_cpu<br>__dma_unmap_area<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">/*<br> *__dma_unmap_area(start, size, dir)<br> *- start- kernel virtual start address<br> *- size- size of region<br> *- dir- DMA direction<br> */<br>ENTRY(__dma_unmap_area)<br>cmpw2, #DMA_TO_DEVICE<br>b.ne__dma_inv_area<br>ret<br>ENDPIPROC(__dma_unmap_area)<br></code></pre></td></tr></table></figure><blockquote><p>每次操作内存时，在 <code>dma_map_sg</code> 的时候执行一次 cache flush 操作，在 <code>dma_unmap_sg</code> 的时候执行一次 cache invalidate 操作，而这中间的过程是不保证 cache 和 ddr 上数据的一致性的</p></blockquote><p>但如果真有在此期间操作内存的场景呢？<code>dma_buf</code> 也想到了，给我们提供了两个 API：</p><ul><li><code>dma_buf_begin_cpu_access</code>：会调用 <code>dma_sync_sg_for_cpu</code>，最终调用 <code>__dma_inv_area</code> 来将 cpu 中的 cache 无效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_sg_for_cpu<br>dma_direct_sync_sg_for_cpu<br>    arch_sync_dma_for_cpu <span class="hljs-comment">// 对每一个 scatterlist 上的内存对应的 cache 进行操作</span><br>    __dma_unmap_area<br>    __dma_inv_area<br></code></pre></td></tr></table></figure><ul><li><code>dma_buf_begin_cpu_access</code>：会调用 <code>dma_sync_sg_for_device</code>，最终调用 <code>__dma_clean_area</code> 来将 cpu 中的 cache flush 到内存中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_sg_for_device<br>dma_direct_sync_sg_for_device<br>arch_sync_dma_for_device <span class="hljs-comment">// 对每一个 scatterlist 上内存对应的 cache 进行操作</span><br>    __dma_map_area<br>    __dma_clean_area<br></code></pre></td></tr></table></figure><p>我们这里举个例子 <a href="https://elixir.bootlin.com/linux/v4.14.143/source/Documentation/DMA-API-HOWTO.txt#L687">DMA-API-HOWTO.txt</a>  ：</p><p><strong>my_card</strong> 驱动调用 <code>dma_map_single</code> 将接收缓冲区映射到 DMA 硬件，然后发起了 DMA 传输请求，等待接收数据完成。当接收完数据后，会触发中断（<code>my_card_interrupt_handler</code>），此时驱动需要在中断里检查本次传输数据的有效性。如果是有效数据，就调用 <code>dma_unmap_single</code> 结束本次 DMA 映射。</p><p>在这个过程中，检查数据有效性是通过 cpu 读取接收缓冲区中的 <code>my_card_header</code> 来实现的，也只有在数据检查完成后，才能决定是否执行 <code>dma_unmap_single</code> 操作。因此这里出现了 dma map 和 unmap 期间 cpu 有访问这段内存的需求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c">my_card_setup_receive_buffer(<span class="hljs-keyword">struct</span> my_card *cp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)<br>&#123;<br>    <span class="hljs-type">dma_addr_t</span> mapping;<br><br>    <span class="hljs-comment">// mmaping 为 dma 地址，buffer 为虚拟地址</span><br>    mapping = dma_map_single(cp-&gt;dev, buffer, len, DMA_FROM_DEVICE);<br>    <span class="hljs-keyword">if</span> (dma_mapping_error(cp-&gt;dev, mapping)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * reduce current DMA mapping usage,</span><br><span class="hljs-comment">         * delay and try again later or</span><br><span class="hljs-comment">         * reset driver.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">goto</span> map_error_handling;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 dma 硬件</span><br>    cp-&gt;rx_buf = buffer;<br>    cp-&gt;rx_len = len;<br>    cp-&gt;rx_dma = mapping;<br><br>    give_rx_buf_to_card(cp);<br>&#125;<br><br>...<br><br>my_card_interrupt_handler(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *devid, <span class="hljs-keyword">struct</span> pt_regs *regs)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_card</span> *<span class="hljs-title">cp</span> =</span> devid;<br><br>    ...<br>    <span class="hljs-keyword">if</span> (read_card_status(cp) == RX_BUF_TRANSFERRED) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_card_header</span> *<span class="hljs-title">hp</span>;</span><br><br>        <span class="hljs-comment">/* Examine the header to see if we wish</span><br><span class="hljs-comment">         * to accept the data.  But synchronize</span><br><span class="hljs-comment">         * the DMA transfer with the CPU first</span><br><span class="hljs-comment">         * so that we see updated contents.</span><br><span class="hljs-comment">         */</span><br>        dma_sync_single_for_cpu(&amp;cp-&gt;dev, cp-&gt;rx_dma,<br>                    cp-&gt;rx_len,<br>                    DMA_FROM_DEVICE);<br><br>        <span class="hljs-comment">/* Now it is safe to examine the buffer. */</span><br>        hp = (<span class="hljs-keyword">struct</span> my_card_header *) cp-&gt;rx_buf;<br>        <span class="hljs-keyword">if</span> (header_is_ok(hp)) &#123;<br>            dma_unmap_single(&amp;cp-&gt;dev, cp-&gt;rx_dma, cp-&gt;rx_len,<br>                     DMA_FROM_DEVICE);<br>            pass_to_upper_layers(cp-&gt;rx_buf);<br>            make_and_setup_new_rx_buf(cp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/* CPU should not write to</span><br><span class="hljs-comment">             * DMA_FROM_DEVICE-mapped area,</span><br><span class="hljs-comment">             * so dma_sync_single_for_device() is</span><br><span class="hljs-comment">             * not needed here. It would be required</span><br><span class="hljs-comment">             * for DMA_BIDIRECTIONAL mapping if</span><br><span class="hljs-comment">             * the memory was modified.</span><br><span class="hljs-comment">             */</span><br>            give_rx_buf_to_card(cp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="importer"><a href="#importer" class="headerlink" title="importer"></a>importer</h3><p>这里我们设计两个 importer：</p><p><code>importer_w</code>：向共享 buf 写数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/dma-buf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/miscdevice.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">importer_w1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_attachment</span> *<span class="hljs-title">attachment</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> *<span class="hljs-title">table</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> reg_addr, reg_size;<br><br>dev = kzalloc(<span class="hljs-keyword">sizeof</span>(*dev), GFP_KERNEL);<br>dev_set_name(dev, <span class="hljs-string">&quot;importer_w&quot;</span>);<br><br>attachment = dma_buf_attach(dmabuf, dev);<br>table = dma_buf_map_attachment(attachment, DMA_BIDIRECTIONAL);<br><br>reg_addr = sg_dma_address(table-&gt;sgl);<br>reg_size = sg_dma_len(table-&gt;sgl);<br><br><span class="hljs-comment">// 这里一般要设置 dma 寄存器</span><br>pr_info(<span class="hljs-string">&quot;reg_addr = 0x%08x, reg_size = 0x%08x\n&quot;</span>, reg_addr, reg_size);<br><br>dma_buf_unmap_attachment(attachment, table, DMA_BIDIRECTIONAL);<br>dma_buf_detach(dmabuf, attachment);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">importer_w2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf)</span><br>&#123;<br><span class="hljs-type">void</span> *vaddr;<br><br>vaddr = dma_buf_kmap(dmabuf, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">sprintf</span>(vaddr, <span class="hljs-string">&quot;hello dma_buf&quot;</span>);<br>pr_info(<span class="hljs-string">&quot;write from dmabuf kmap: %s\n&quot;</span>, );<br>dma_buf_kunmap(dmabuf, <span class="hljs-number">0</span>, vaddr);<br><br><span class="hljs-comment">// vaddr = dma_buf_vmap(dmabuf);</span><br><span class="hljs-comment">// dma_buf_vunmap(dmabuf, vaddr);</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">importer_w_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf</span> *<span class="hljs-title">dmabuf</span>;</span><br><br><span class="hljs-keyword">if</span> (copy_from_user(&amp;fd, (<span class="hljs-type">void</span> __user *)arg, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br>dmabuf = dma_buf_get(fd);<br><br>importer_w2(dmabuf);<br><br>dma_buf_put(dmabuf);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">importer_w_fops</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.unlocked_ioctl= importer_w_ioctl,<br>&#125;;<br> <br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscdevice</span> <span class="hljs-title">mdev</span> =</span> &#123;<br>.minor = MISC_DYNAMIC_MINOR,<br>.name = <span class="hljs-string">&quot;importer_w&quot;</span>,<br>.fops = &amp;importer_w_fops,<br>&#125;;<br> <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">importer_w_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> misc_register(&amp;mdev);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">importer_w_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>misc_deregister(&amp;mdev);<br>&#125;<br><br>module_init(importer_w_init);<br>module_exit(importer_w_exit);<br><br>MODULE_AUTHOR(<span class="hljs-string">&quot;xiaoa&quot;</span>);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>importer_r</code>：从共享 buf 读数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/dma-buf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/miscdevice.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">importer_r1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf_attachment</span> *<span class="hljs-title">attachment</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> *<span class="hljs-title">table</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> reg_addr, reg_size;<br><br>dev = kzalloc(<span class="hljs-keyword">sizeof</span>(*dev), GFP_KERNEL);<br>dev_set_name(dev, <span class="hljs-string">&quot;importer_r&quot;</span>);<br><br>attachment = dma_buf_attach(dmabuf, dev);<br>table = dma_buf_map_attachment(attachment, DMA_BIDIRECTIONAL);<br><br>reg_addr = sg_dma_address(table-&gt;sgl);<br>reg_size = sg_dma_len(table-&gt;sgl);<br><br>pr_info(<span class="hljs-string">&quot;%s read %s&quot;</span>, dev_name(dev), (<span class="hljs-type">char</span> *)sg_virt(table-&gt;sgl));<br><br>dma_buf_unmap_attachment(attachment, table, DMA_BIDIRECTIONAL);<br>dma_buf_detach(dmabuf, attachment);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">importer_r2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf)</span><br>&#123;<br><span class="hljs-type">void</span> *vaddr;<br><br>vaddr = dma_buf_kmap(dmabuf, <span class="hljs-number">0</span>);<br>pr_info(<span class="hljs-string">&quot;read from dmabuf kmap: %s\n&quot;</span>, (<span class="hljs-type">char</span> *)vaddr);<br>dma_buf_kunmap(dmabuf, <span class="hljs-number">0</span>, vaddr);<br><br><span class="hljs-comment">// vaddr = dma_buf_vmap(dmabuf);</span><br><span class="hljs-comment">// dma_buf_vunmap(dmabuf, vaddr);</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">importer_r_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_buf</span> *<span class="hljs-title">dmabuf</span>;</span><br><br><span class="hljs-keyword">if</span> (copy_from_user(&amp;fd, (<span class="hljs-type">void</span> __user *)arg, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br>dmabuf = dma_buf_get(fd);<br><br>importer_r2(dmabuf);<br><br>dma_buf_put(dmabuf);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">importer_fops</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.unlocked_ioctl= importer_r_ioctl,<br>&#125;;<br> <br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscdevice</span> <span class="hljs-title">mdev</span> =</span> &#123;<br>.minor = MISC_DYNAMIC_MINOR,<br>.name = <span class="hljs-string">&quot;importer_r&quot;</span>,<br>.fops = &amp;importer_fops,<br>&#125;;<br> <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">importer_r_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> misc_register(&amp;mdev);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">importer_r_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>misc_deregister(&amp;mdev);<br>&#125;<br><br>module_init(importer_r_init);<br>module_exit(importer_r_exit);<br><br>MODULE_AUTHOR(<span class="hljs-string">&quot;xiaoa&quot;</span>);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><p>两个 importer 代码基本一样，就统一讲述了</p><p>importer 通过 <code>ioctl</code> 从用户空间获取到 <code>dma_buf</code> 的 fd，然后调用 <code>dma_buf_get</code> 拿到 <code>dma_buf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dma_buf *<span class="hljs-title function_">dma_buf_get</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br><br>file = fget(fd);<br><br><span class="hljs-keyword">if</span> (!file)<br><span class="hljs-keyword">return</span> ERR_PTR(-EBADF);<br><br><span class="hljs-keyword">if</span> (!is_dma_buf_file(file)) &#123;<br>fput(file);<br><span class="hljs-keyword">return</span> ERR_PTR(-EINVAL);<br>&#125;<br><br><span class="hljs-keyword">return</span> file-&gt;private_data;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>dma_buf</code> 引用计数会加 1，如果不用的话记得调用 <code>dma_buf_put</code> 减 1，否则无法 <code>rmmod</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dma_buf_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dma_buf *dmabuf)</span><br>&#123;<br><span class="hljs-keyword">if</span> (WARN_ON(!dmabuf || !dmabuf-&gt;file))<br><span class="hljs-keyword">return</span>;<br><br>fput(dmabuf-&gt;file);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着调用我们的测试函数，这里有两个函数，分别是会调用软件访问的 API 和 DMA 硬件访问的 API</p><p>先看软件访问 API：</p><p><code>importer_r2/importer_w2</code>：</p><ul><li><code>dma_buf_kmap</code> -&gt; <code>mock_dmabuf_kmap</code> -&gt; <code>kmap</code>  获取虚拟地址</li><li>开始读写</li><li><code>dma_buf_kmap</code>-&gt;<code>mock_dmabuf_kmap</code>-&gt;<code>kumap</code>，为空函数</li></ul><p>再看 DMA 硬件访问 API：</p><p><code>importer_r1/importer_w1</code>：</p><ul><li>调用 <code>dma_buf_attach</code>  返回 <code>attachment</code>，将 <code>dma_buf</code> 和 importer 绑定</li><li>将 <code>attachment</code>  作为参数调用 <code>dma_buf_map_attachment</code>，初始化 <code>sg_table</code> 和 <code>scatterlist</code>，同步 cache</li><li>通过 <code>sg_dma_address</code> 获取到 dma 地址，通过 <code>sg_dma_len</code> 获取到长度，然后就可以设置 dma 寄存器了</li><li>调用 <code>dma_buf_map_attachment</code> 同步 cache</li><li>调用 <code>dma_buf_detach</code> 将 <code>dma_buf</code> 和 importer 解绑</li></ul><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>我们这里涉及三步骤：</p><ul><li><p>通过 ioctl 向 exporter 获取 <code>dma_buf</code> 的 fd</p></li><li><p>将 fd 传给 importer_w</p></li><li><p>将 fd 传给 importer_r</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">int</span> dmabuf_fd = <span class="hljs-number">0</span>;<br><br>fd = open(<span class="hljs-string">&quot;/dev/mock_dmabuf&quot;</span>, O_RDONLY);<br>ioctl(fd, <span class="hljs-number">0</span>, &amp;dmabuf_fd);<br>close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/dev/importer_w&quot;</span>, O_RDWR);<br>ioctl(fd, <span class="hljs-number">0</span>, &amp;dmabuf_fd);<br>close(fd);<br><br>    sleep(<span class="hljs-number">3</span>);<br><br>    fd = open(<span class="hljs-string">&quot;/dev/importer_r&quot;</span>, O_RDWR);<br>ioctl(fd, <span class="hljs-number">0</span>, &amp;dmabuf_fd);<br>close(fd);<br><br><span class="hljs-comment">// char *str = mmap(NULL, 4096, PROT_READ, MAP_SHARED, dmabuf_fd, 0);</span><br><span class="hljs-comment">// printf(&quot;read from dmabuf mmap: %s\n&quot;, str);</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果为：</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309271946163.jpg" alt="hKXPN2yMsH"></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/08/linux/kernel/other/DMA/Dynamic%20DMA%20mapping%20Guide/"/>
    <url>/2023/10/08/linux/kernel/other/DMA/Dynamic%20DMA%20mapping%20Guide/</url>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-DMA-mapping-Guide"><a href="#Dynamic-DMA-mapping-Guide" class="headerlink" title="Dynamic DMA mapping Guide"></a>Dynamic DMA mapping Guide</h1><span id="more"></span><p>这是一篇指导驱动工程师如何使用 DMA API 的文档，为了方便理解，文档中给出了伪代码的例程。有关 API 的简要描述，请参见 <strong>DMA-API.tx</strong>t。</p><h2 id="CPU-虚拟地址和-DMA-总线地址"><a href="#CPU-虚拟地址和-DMA-总线地址" class="headerlink" title="CPU 虚拟地址和 DMA 总线地址"></a>CPU 虚拟地址和 DMA 总线地址</h2><p>在 DMA API中涉及好几个地址的概念（<strong>虚拟地址、物理地址、总线地址</strong>），正确的理解这些地址是非常重要的。</p><p>内核通常使用的地址是虚拟地址。我们调用 <code>kmalloc()</code>、<code>vmalloc()</code>或者类似的接口返回的地址都是虚拟地址，保存在<code>&quot;void *&quot;</code>的变量中。</p><p>虚拟内存系统（TLB、页表等）将虚拟地址转换成物理地址（CPU角度），物理地址保存在<code>phys_addr_t</code>或<code>resource_size_t</code>变量中。对于一个硬件设备上的寄存器等设备资源，内核是按照物理地址来管理的。通过 <code>/proc/iomem</code>，你可以看到这些和设备 IO 相关的物理地址。当然，驱动并不能直接使用这些物理地址，必须首先通过 <code>ioremap()</code> 接口将这些物理地址映射到内核虚拟地址空间上去。</p><p><em>I&#x2F;O</em> 设备使用第三种地址：<strong>总线地址</strong>。如果设备在 MMIO 地址空间中有寄存器，它可以通过 DMA 执行读写系统内存的操作，这时设备使用的地址就是总线地址。在某些系统中，总线地址与 CPU 物理地址相同，但一般来说它们不是。IOMMUs 和 host bridge 可以在物理地址和总线地址之间进行映射。</p><p>从设备的角度来看，DMA 控制器使用总线地址空间，不过可能仅限于总线空间的一个子集。例如，即便是一个系统支持 64 位地址内存和 64 位地址的 PCI bar，但是 DMA 可以不使用全部的 64 bit 地址，通过 IOMMU 映射，PCI 设备上的 DMA 可以只使用 32 位 DMA 地址。</p><p>这里有一张图片和一些例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">             CPU                  CPU                  Bus<br>           Virtual              Physical             Address<br>           Address              Address               Space<br>            Space                Space<br><br>          +-------+             +------+             +------+<br>          |       |             |MMIO  |   Offset    |      |<br>          |       |  Virtual    |Space |   applied   |      |<br>        C +-------+ --------&gt; B +------+ ----------&gt; +------+ A<br>          |       |  mapping    |      |   by host   |      |<br>+-----+   |       |             |      |   bridge    |      |   +--------+<br>|     |   |       |             +------+             |      |   |        |<br>| CPU |   |       |             | RAM  |             |      |   | Device |<br>|     |   |       |             |      |             |      |   |        |<br>+-----+   +-------+             +------+             +------+   +--------+<br>          |       |  Virtual    |Buffer|   Mapping   |      |<br>        X +-------+ --------&gt; Y +------+ &lt;---------- +------+ Z<br>          |       |  mapping    | RAM  |   by IOMMU<br>          |       |             |      |<br>          |       |             |      |<br>          +-------+             +------+<br></code></pre></td></tr></table></figure><p>在 PCI 枚举过程中，内核了解 I&#x2F;O 设备及其 MMIO 空间，以及将它们连接到系统的主机桥接起来。例如，如果 PCI 设备有一个 BAR（base address register），内核从 BAR 中读取总线地址 <strong>(A)</strong> 并将其转换为 CPU 物理地址 **(B)**。地址 <strong>B</strong> 存储在 <code>struct resource</code> 中，通常通过 <code>/proc/iomem</code> 暴露给用户。当驱动程序声明一个设备时，它通常使用<code>ioremap()</code> 将物理地址 <strong>B</strong> 映射到虚拟地址 **(C)**。然后它可以使用例如 <code>ioread32(C)</code> 来访问总线地址 A 的设备寄存器。</p><p>如果设备支持 DMA，驱动程序使用 <code>kmalloc()</code> 或类似的接口建立一个缓冲区，返回一个虚拟地址 **(X)**，虚拟内存系统将 <strong>X</strong> 映射到系统 RAM 中的物理地址 **(Y)**。驱动程序可以使用虚拟地址 <strong>X</strong> 访问缓冲区，但是设备本身不能，因为 DMA不经过 CPU 虚拟内存系统。</p><p>在一些简单的系统中，设备可以通过 DMA 直接访问物理地址 <strong>Y</strong>，但是在大多数的系统中，有一个 IOMMU 的硬件用来将 DMA 可访问的<strong>总线地址</strong>转换成<strong>物理地址</strong>，也就是把上图中的地址 <strong>Z</strong> 转换成 <strong>Y</strong>。理解了这些底层硬件，你也就知道类似 <code>dma_map_single</code> 这样的 DMA API 是在做什么了。驱动在调用 <code>dma_map_single</code> 接口函数的时候会传递一个虚拟地址 <strong>X</strong>，在这个函数中会设定 IOMMU 的页表，将地址 <strong>X</strong> 映射到 <strong>Z</strong>，并且将返回 <strong>Z</strong> 这个总线地址。驱动可以把 <strong>Z</strong> 总线地址设定到设备上的 DMA 相关寄存器中。这样，当设备发起对<strong>总线地址 Z</strong> 的DMA 操作时，IOMMU 就进行地址映射，并将 DMA 操作定位到 <strong>Y</strong> 地址开始的 DMA buffer。</p><p>根据上面的描述我们可以得出这样的结论：Linux 可以使用动态 DMA 映射（<strong>dynamic DMA mapping</strong>）的方法，当然，这需要一些来自驱动的协助。所谓动态 DMA 映射是指只有在使用的时候，才建立 DMA buffer 虚拟地址到总线地址的映射，一旦 DMA 传输完毕，就将之前建立的映射关系销毁。</p><p>虽然上面的例子使用 IOMMU 为例描述，不过本文随后描述的 API 也可以在没有 IOMMU 硬件的平台上运行。</p><p>顺便说明一点：DMA API 适用于各种处理器架构，DMA mapping framework 已经屏蔽了底层硬件的细节。对于驱动工程师而言，你应该使用通用的 DMA API（例如 <code>dma_map_*()</code> 接口函数），而不是和特定总线相关的 API（例如<code>pci_map_*()</code> 接口函数）。</p><p>驱动想要使用 DMA mapping framework 的 API，需要首先包含相关头文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/dma-mapping.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>这个头文件中定义了 <code>dma_addr_t</code> 这种数据类型，而这种类型的变量可以保存任何有效的 DMA 地址，不管是什么总线，什么处理器架构。驱动调用了 DMA API 之后，返回的 DMA 地址（总线地址）就是这种类型的。</p><h2 id="什么地址可以用作-DMA"><a href="#什么地址可以用作-DMA" class="headerlink" title="什么地址可以用作 DMA"></a>什么地址可以用作 DMA</h2><p>既然驱动想要使用 DMA mapping framework 提供的接口，我们首先需要知道的就是是否所有的系统内存都是可以调用DMA API 进行映射？那么这些可以让 DMA 控制器访问系统内存有什么特点？关于这一点，一直以来有一些不成文的规则，在本文中我们看看是否能够将其全部记录下来。</p><p>如果驱动是通过伙伴系统的接口（例如 <code>__get_free_page*()</code>）或者类似 <code>kmalloc()</code>、 <code>kmem_cache_alloc()</code>这样的通用内存分配的接口来分配 DMA buffer，那么这些接口函数返回的虚拟地址可以直接用于 DMA mapping 接口API，并通过 DMA 操作在外设和 dma buffer 中交换数据。</p><p>使用 <code>vmalloc()</code> 分配的 DMA buffer 可以直接使用吗？最好不要这样，虽然强行使用也没有问题，但是终究是比较麻烦。首先，<code>vmalloc</code> 分配的物理页面是不连续的，如果底层硬件需要物理内存连续，那么 <code>vmalloc</code> 分配的内存不能满足硬件要求。即便是底层 DMA 硬件支持 scatter-gather，<code>vmalloc</code> 分配出来的内存仍然存在其他问题。我们知道 <code>vmalloc</code> 分配的虚拟地址和对应的物理地址没有线性关系（<code>kmalloc</code> 或者 <code>__get_free_page</code> 这样的接口，其返回的虚拟地址和物理地址有一个固定偏移的关系，即 PAGE_OFFSET），而在做 DMA mapping 的时候，需要知道物理地址，有线性关系的虚拟地址很容易可以获取其物理地址，但是对于 <code>vmalloc</code> 分配的虚拟地址，我们需要遍历页表才可以找到其物理地址。</p><p>该规则还意味着您既不能使用内核映像地址(data&#x2F;text&#x2F;bss 段)，也不能使用内核模块映像地址，即使这些内存可以物理地使用DMA。您也需要确保 I&#x2F;O 缓冲区与 cache line 对齐。否则会有 cpu 和 dma 都写同一个 cache line 而导致数据被覆盖的问题。</p><p>通过 <code>kmap</code> 接口返回的内存也可以做 DMA buffe，其原理类似 <code>vmalloc</code>。</p><p>块设备和网络设备使用的 buffer 可以确保可以使用 DMA 操作。</p><h2 id="DMA-地址的限制"><a href="#DMA-地址的限制" class="headerlink" title="DMA 地址的限制"></a>DMA 地址的限制</h2><p>你的设备有 DMA 地址的限制吗？比如你的设备只能访问低 24 的内存地址，如果是这样，你需要把这个限制告诉内核。</p><p>默认情况下，内核可以确保你的设备可以访问全部的 32 位地址空间。对于 64 位也一样。</p><p>关于 PCI 的特别注意事项: PCI- x 规范要求 PCI- x 设备支持所有事务的 64 位寻址。当 IO 总线处于 PCI-X 模式时，至少有一个平台(SGI SN2)需要 64 位一致的分配才能正确运行。</p><p>如果有寻址限制，那么在该外设驱动的 probe 函数中，你需要询问内核，看看是否有 DMA controller 可以支持这个外设的寻址限制。虽然有缺省的寻址限制的设定，不过最好还是在 probe 函数中进行相关处理，至少这说明你已经为你的外设考虑过寻址限制这事了。</p><p>一旦确定了设备 DMA 寻址限制之后，我们可以通过下面的接口进行设定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_mask_and_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span>;<br></code></pre></td></tr></table></figure><p>上面的接口用询问 streaming 和 coherent 两种 dma buffer</p><p>根据 DMA buffer 的特性，DMA 操作有两种：</p><ul><li><strong>streaming</strong>：DMA buffer 是一次性的，用完就算。但是需要自己考虑 cache 一致性</li><li><strong>cache coherent</strong>：这种 DMA buffer 往往是静态的、长时间存在的。</li></ul><p>如果你知道你想用的是哪种接口，那旧直接调用对应的接口</p><p>streaming 接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span>;<br></code></pre></td></tr></table></figure><p>consistent allocations 接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_coherent_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span>;<br></code></pre></td></tr></table></figure><p><code>dev</code> 指向该设备的 <code>struct device</code> 对象，一般来说，这个 <code>struct device</code> 对象应该是嵌入在 bus-specific 的实例中，例如对于 PCI 设备，有一个 <code>struct pci_dev</code> 的实例与之对应，而在这里需要传入的 <code>dev</code> 参数则可以通过 <code>&amp;pdev-&gt;dev</code> 得到（<code>pdev</code> 指向 <code>struct pci_dev</code> 的实例）。<code>mask</code> 表示你的设备支持的地址信息。</p><p>如果返回值非 0，那么说明这样的 DMA 寻址是不能正确完成的，如果强行这么做将会产生不可预知的后果。驱动必须检测返回值，如果不行，那么建议修改 mask 或者不使用DMA。</p><p>也就是说，对上面接口调用失败后，你有三个选择：</p><ul><li>使用另一个 DMA mask</li><li>使用非 DMA 方式</li><li>忽略这个设备，不初始化它</li></ul><p>标准的 32 位寻址设备会这样做:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="hljs-number">32</span>))) &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: No suitable DMA available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个常见的场景是有 64 位寻址能力的设备。一般来说我们会首先尝试设定 64 位的地址掩码，但是这时候有可能会失败，从而将掩码降低为 3 2位。内核之所以会在设定 64 位掩码的时候失败，这并不是因为平台不能进行 64 位寻址，而仅仅是因为 32 位寻址比 64 位寻址效率更高。例如，SPARC64 平台上，PCI SAC 寻址比 DAC 寻址性能更好。</p><p>下面就是如何使用 streaming 的 DMA 来配置 64 位设备：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> using_dac;<br><br><span class="hljs-keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="hljs-number">64</span>))) &#123;<br>    using_dac = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="hljs-number">32</span>))) &#123;<br>    using_dac = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: No suitable DMA available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要使用 dma coherent 的方式来配置 64 位设备：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> using_dac, consistent_using_dac;<br><br><span class="hljs-keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="hljs-number">64</span>))) &#123;<br>    using_dac = <span class="hljs-number">1</span>;<br>    consistent_using_dac = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="hljs-number">32</span>))) &#123;<br>    using_dac = <span class="hljs-number">0</span>;<br>    consistent_using_dac = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: No suitable DMA available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure><p>coherent 地址掩码总是等于或者小于 streaming 地址掩码，因此，一般来说，我们只要设定了 streaming 地址掩码成功了，那么使用同样的掩码或者小一些的掩码来设定 coherent 地址掩码总是会成功，因此这时候我们一般就不检查 <code>dma_set_coherent_mask</code> 的返回值了，当然，有些设备很奇怪，只能使用 coherent DMA，那么这种情况下，驱动需要检查 <code>dma_set_coherent_mask</code> 的返回值。</p><p>最后，如果你的设备只能使用低 24 位的地址空间，你应该这样设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (dma_set_mask(dev, DMA_BIT_MASK(<span class="hljs-number">24</span>))) &#123;<br>    dev_warn(dev, <span class="hljs-string">&quot;mydev: 24-bit DMA addressing not available\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> ignore_this_device;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 <code>dma_set_mask()</code> 或 <code>dma_set_mask_and_coherent()</code> 返回 0，说明成功了，内核一定要保存好这个 mask。因为一会要用这个 mask 调用 dma mapping 接口。</p><p>这里还有一个需要提到的场景：比如一个声卡设备提供了播放和录音功能，每个功能都需要 dma，而两个需要的 dma 地址范围又不一样，所以需要分别调用 <code>dma_set_mask()</code>l来设置。</p><p>下面是段伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLAYBACK_ADDRESS_BITSDMA_BIT_MASK(32)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RECORD_ADDRESS_BITSDMA_BIT_MASK(24)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_sound_card</span> *<span class="hljs-title">card</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br><br>...<br><span class="hljs-keyword">if</span> (!dma_set_mask(dev, PLAYBACK_ADDRESS_BITS)) &#123;<br>    card-&gt;playback_enabled = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    card-&gt;playback_enabled = <span class="hljs-number">0</span>;<br>    dev_warn(dev, <span class="hljs-string">&quot;%s: Playback disabled due to DMA limitations\n&quot;</span>,<br>           card-&gt;name);<br>&#125;<br><span class="hljs-keyword">if</span> (!dma_set_mask(dev, RECORD_ADDRESS_BITS)) &#123;<br>    card-&gt;record_enabled = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    card-&gt;record_enabled = <span class="hljs-number">0</span>;<br>    dev_warn(dev, <span class="hljs-string">&quot;%s: Record disabled due to DMA limitations\n&quot;</span>,<br>           card-&gt;name);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DMA-mappings-的类型"><a href="#DMA-mappings-的类型" class="headerlink" title="DMA mappings 的类型"></a>DMA mappings 的类型</h2><p>有两种类型的 DMA mapping 接口</p><h3 id="Consistent-DMA-mappings"><a href="#Consistent-DMA-mappings" class="headerlink" title="Consistent DMA mappings"></a>Consistent DMA mappings</h3><ul><li>它总是在驱动初始化的时候进行 map，在硬件结束的时候 unmap。</li><li>CPU 和 DMA controller 在发起对 DMA buffer 的并行访问的时候不需要考虑 cache 的影响，也就是说不需要软件进行 cache 操作，CPU 和 DMA controller 都可以看到对方对 DMA buffe r的更新。</li></ul><p>实际上一致性 DMA 映射中的那个 consistent 实际上可以称为 <code>synchronous</code> 或 <code>coherent</code>，即 cache coherent。</p><p>缺省情况下，coherent mask 被设定为低 32 bit，即使这样可以满足驱动的需求，但为了将来的兼容性，也建议你通过接口在驱动中设定 coherent mask。</p><p>下面有一些 dma coherent mapping 的好的例子：</p><ul><li>网卡驱动和网卡 DMA 控制器往往是通过一些内存中的描述符（形成环或者链）进行交互，这些保存描述符的内存一般采用 Consistent DMA mapping</li><li>SCSI 硬件适配器上的 DMA 使用一些数据结构（mailbox command）进行交互，这些保存 mailbox command 的内存一般采用 Consistent DMA mapping。</li><li>有些外设有能力执行主存上的固件代码（microcode），这些保存 microcode 的主存一般采用 Consistent DMA mapping。</li></ul><p>上面的这些例子有同样的特性：cpu 对内存的修改可以立刻被外设感知到，反之亦然，一致性映射可以保证这一点。</p><p>需要注意的是：一致性的 DMA 映射并不意味着不需要 memory barriers 来保证内存顺序，CPU 有可能为了性能而重排对 consistent memory 上内存访问指令。例如：如果在DMA consistent memory 上有两个 word，分别是 word0 和 word1，对于 device 一侧，必须保证 word0 先更新，然后才有对 word1 的更新，那么你需要这样写代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">desc-&gt;word0 = address;<br>wmb();<br>desc-&gt;word1 = DESC_VALID;<br></code></pre></td></tr></table></figure><p>只有这样才能保证在所有的平台上的设备驱动可以正常的工作。</p><p>此外，在有些平台上，修改了 DMA Consistent buffer 后，你的驱动可能需要 flush write buffer，以便让 device 侧感知到 memory 的变化。这个动作类似在 PCI 桥中的 flush write buffer 的动作。</p><h3 id="Streaming-DMA-mappings"><a href="#Streaming-DMA-mappings" class="headerlink" title="Streaming DMA mappings"></a>Streaming DMA mappings</h3><p>流式 DMA 映射是一次性的，一般是需要进行 DMA 传输的时候才进行 mapping，一旦DMA 传输完成，就立刻 ummap（除非你使用 dma_sync_*的接口，下面会描述）。并且硬件可以为顺序化访问进行优化。</p><p>streaming 可以被认为是 asynchronous，或者是不属于 coherent memory 范围</p><p>下面有几个使用 streaming mapping 好的例子：</p><ul><li>网卡进行数据传输使用的 DMA buffer</li><li>文件系统中的各种数据 buffer，这些 buffer 中的数据最终到读写到 SCSI 设备上去，一般而言，驱动会接受这些 buffer，然后进行 streaming DMA mapping，之后和 SCSI 设备上的 DMA 进行交互。</li></ul><p>设计 streaming DMA mapping 这样的接口是为了充分优化硬件的性能，为了达到这个目标，在使用这些接口的时候，你必须清清楚楚的知道调用接口会发生什么。</p><p>无论哪种类型的 DMA 映射都有对齐的限制，这些限制来自底层的总线，当然也有可能是某些总线上的设备有这样的限制。此外，如果系统中的 cache 并不是 DMA coherent 的，而且底层的 DMA buffer 不和其他数据共享 cacheline，这样的系统将工作的更好。</p><h3 id="如何使用-Consistent-DMA-mappings"><a href="#如何使用-Consistent-DMA-mappings" class="headerlink" title="如何使用 Consistent DMA mappings"></a>如何使用 Consistent DMA mappings</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>为了分配并映射一个较大（PAGE_SIZE 大小或者类似）的 coherent DMA memory，你需要调用下面的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle;<br>cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);<br></code></pre></td></tr></table></figure><p>DMA 操作总是会涉及具体设备上的 DMA controller，而 <code>dev</code> 参数就是执行该设备的<code>struct device</code> 对象的。</p><p><code>size</code> 参数指明了你想要分配的 DMA Buffer 的大小，byte 为单位</p><p><code>dma_alloc_coherent</code> 这个接口也可以在中断上下文调用，当然，<code>gfp</code> 参数要传递 <code>GFP_ATOMIC</code> 标记，<code>gfp</code> 是内存分配的 flag，<code>dma_alloc_coherent</code> 仅仅是透传该 flag 到内存管理模块。</p><p>如果传入非空的 <code>dev</code> 参数，即使驱动调用了掩码设置接口函数设定了 DMA mask，说明该设备可以访问大于 32 位地址空间，一致性 DMA 映射的接口函数也一般会默认的返回一个 32 位可寻址的 DMA buffer 地址。要知道 dma mask 和 coherent dma mask 是不同的，除非驱动显示的调用 <code>dma_set_coherent_mask()</code> 接口来修改 coherent dma mask，例如大小大于 32 位地址，<code>dma_alloc_coherent</code> 接口函数才会返回大于 32 位地址空间的地址。dma pool 接口也是如此。</p><p><code>dma_alloc_coherent</code> 函数返回两个值，一个是从 cpu 角度访问 DMA buffer 的虚拟地址，另外一个是从设备（DMA controller）角度看到的总线地址：<code>dma_handle</code>，驱动可以将这个总线地址传递给硬件。</p><p>即便是请求的 DMA buffer 的大小小于 PAGE SIZE，<code>dma_alloc_coherent</code> 返回的 cpu虚拟地址和 DMA 总线地址都保证对齐在最小的 PAGE_SIZE 上，这个特性确保了分配的DMA buffer 有这样的特性：如果 PAGE_SIZE 是 64K，即便是驱动分配一个小于或者等于64K 的dma buffer，那么 DMA buffer 不会越过 64K 的边界。</p><h4 id="unmap"><a href="#unmap" class="headerlink" title="unmap"></a>unmap</h4><p>当驱动需要 umap 并释放 dma buffer 的时候，需要调用下面的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_free_coherent(dev, size, cpu_addr, dma_handle);<br></code></pre></td></tr></table></figure><p>这个接口函数的 <code>dev</code>、<code>size</code> 参数上面已经描述过了，而 <code>cpu_addr</code> 和 <code>dma_handle</code> 参数就是 <code>dma_alloc_coherent()</code> 接口的那两个地址返回值。需要强调的一点就是：和 <code>dma_alloc_coherent</code> 不同，<code>dma_free_coherent</code> 不能在中断上下文中调用。（因为在有些平台上，free DMA 的操作会引发 TLB 维护的操作（从而引发cpu core 之间的通信），如果关闭了中断会锁死在 SMP IPI 的代码中）。</p><h4 id="dma-pool"><a href="#dma-pool" class="headerlink" title="dma_pool"></a>dma_pool</h4><p>如果你的驱动需非常多的小 的dma buffer，那么 dma pool 是最适合你的机制。这个概念类似 <code>kmem_cache</code>。dma pool 就是通过 <code>dma_alloc_coherent</code> 接口获取大块一致性的 DMA 内存，然后驱动可以调用 <code>dma_pool_alloc</code> 从那个大块 DMA 内存中分一个小块的 dma buffer 供自己使用。</p><p>创建一个 <code>dma_pool</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_pool</span> *<span class="hljs-title">pool</span>;</span><br>pool = dma_pool_create(name, dev, size, align, boundary);<br></code></pre></td></tr></table></figure><p>从 <code>dma_pool</code> 分配内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu_addr = dma_pool_alloc(pool, flags, &amp;dma_handle);<br></code></pre></td></tr></table></figure><p>释放 dma 内存到 <code>dma_pool</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_pool_free(pool, cpu_addr, dma_handle);<br></code></pre></td></tr></table></figure><p>销毁 <code>dma_pool</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_pool_destroy(pool);<br></code></pre></td></tr></table></figure><p>你必须保证在调用 <code>dma_pool_destroy</code> 之前先调用 <code>dma_pool_free</code>，并且这个函数不能在中断上下文中调用。</p><h3 id="DMA-操作方向"><a href="#DMA-操作方向" class="headerlink" title="DMA 操作方向"></a>DMA 操作方向</h3><p>由于下面的章节会用到 DMA 操作方向这个概念，因此我们先简单的描述一下，DMA 操作方向定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">DMA_BIDIRECTIONAL<br>DMA_TO_DEVICE<br>DMA_FROM_DEVICE<br>DMA_NONE<br></code></pre></td></tr></table></figure><p>如果你知道的话，你应该尽可能的提供准确的 DMA 操作方向。</p><p><strong>DMA_TO_DEVICE</strong> 表示从内存（dma buffer）到设备，而 **DMA_FROM_DEVICE **表示从设备到内存（dma buffer），上面的这些字符定义了数据在 DMA 操作中的移动方向。</p><p>虽然我们强烈要求驱动在知道 DMA 传输方向的适合，精确的指明是 <strong>DMA_TO_DEVICE</strong> 或者 <strong>DMA_FROM_DEVICE</strong>。</p><p>如果你确实是不知道具体的操作方向，那么设定为 **DMA_BIDIRECTIONAL **也是可以的，表示 DMA 操作可以执行任何一个方向的的数据搬移。你的平台需要保证这一点可以让 DMA正常工作，当然，这也有可能会引入一些性能上的额外开销。</p><p><strong>DMA_NONE</strong> 主要是用于调试。在驱动知道精确的 DMA 方向之前，可以把它保存在 DMA控制数据结构中，在 dma 方向设定有问题的时候，你可以跟踪 dma 方向的设置情况，以便定位问题所在。</p><p>除了潜在的平台相关的性能优化之外，精确地指定 DMA 操作方向还有另外一个优点就是方便调试。有些平台实际上在创建 DMA mapping 的时候，页表（将总线地址映射到物理地址的页表）中有一个写权限布尔值，这个值非常类似于用户程序地址空间中的页保护。当 DMA 控制器硬件检测到违反权限设置时，这样的平台可以将错误写入内核日志，从而方便了调试。</p><p>只有 streaming mappings 才会指明 DMA 操作方向，一致性 DMA 映射隐含的 DMA 操作方向是 <code>DMA_BIDIRECTIONAL</code>。我们举一个 streaming mappings 的例子：在网卡驱动中，如果要发送数据，那么在 map&#x2F;umap 的时候需要指明 <code>DMA_TO_DEVICE</code> 的操作方向，而在接受数据包的时候，map&#x2F;umap 需要指明 DMA 操作方向是<code>DMA_FROM_DEVICE</code>。</p><h3 id="如何使用-Streaming-DMA-mappings"><a href="#如何使用-Streaming-DMA-mappings" class="headerlink" title="如何使用 Streaming DMA mappings"></a>如何使用 Streaming DMA mappings</h3><p>streaming DMA mapping 的接口函数可以在中断上下文中调用。streaming DMA mapping有两个版本的接口函数，一个是用来 map&#x2F;umap 单个的 dma buffer，另外一个是用来map&#x2F;umap 形成 scatterlist 的多个 dma buffer。</p><h4 id="dma-map-single"><a href="#dma-map-single" class="headerlink" title="dma_map_single"></a>dma_map_single</h4><p>map 单个 dma buf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;my_dev-&gt;dev;<br><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-type">void</span> *addr = buffer-&gt;ptr;<br><span class="hljs-type">size_t</span> size = buffer-&gt;len;<br><br>dma_handle = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling;<br>&#125;<br></code></pre></td></tr></table></figure><p>unmap 单个 dma buf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_unmap_single(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure><p>当调用 <code>dma_map_single()</code> 返回错误的时候，你应当调用 <code>dma_mapping_error()</code> 来处理错误。虽然并不是所有的 DMA mapping 实现都支持 <code>dma_mapping_error</code> 这个接口（调用 <code>dma_mapping_error</code> 函数实际上会调用底层 <code>dma_map_ops</code> 操作函数集中的 <code>mapping_error</code> 成员函数），但是调用它来进行出错处理仍然是一个好的做法。这样做的好处是可以确保 DMA mapping 代码在所有 DMA 实现中都能正常工作，而不需要依赖底层实现的细节。没有检查错误就使用返回的地址可能会导致程序失败，可能会产生 kernel panic 或者悄悄的损坏你有用的数据。虽然是这里使用 <code>dma_map_single</code> 作为示例，但同样也是适用于<code>dma_map_page</code>。</p><p>当 DMA 传输完成的时候，程序应该调用 <code>dma_unmap_single()</code> 函数 umap dma buffer。例如：在 DMA 完成传输后会通过中断通知 CPU，而在中断函数中可以调用<code>dma_unmap_single()</code> 函数。<code>dma_map_single</code> 函数在进行 DMA mapping 的时候使用的是 cpu 指针（虚拟地址），这样就导致该函数有一个弊端：不能使用 HIGHMEM memory 进行映射（因为不能线性映射）。鉴于此，map&#x2F;unmap 接口提供了另外一个类似的接口，这个接口不使用 cpu 指针，而是使用 page 和 page offset 来进行 DMA mapping（返回 <code>struct page</code> 数据结构，后续可以根据 page 线性转换为内核虚拟地址）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;my_dev-&gt;dev;<br><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> buffer-&gt;page;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset = buffer-&gt;offset;<br><span class="hljs-type">size_t</span> size = buffer-&gt;len;<br><br>dma_handle = dma_map_page(dev, page, offset, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * reduce current DMA mapping usage,</span><br><span class="hljs-comment"> * delay and try again later or</span><br><span class="hljs-comment"> * reset driver.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">goto</span> map_error_handling;<br>&#125;<br><br>...<br><br>dma_unmap_page(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure><p><code>offset</code> 表示一个指定 page 内的页内偏移（以Byte为单位）。和 <code>dma_map_single</code> 接口函数一样，调用 <code>dma_map_page()</code> 返回错误后需要调用 <code>dma_mapping_error()</code> 来进行错误处理。</p><p>当 DMA 传输完成的时候，你应该调用 <code>dma_unmap_page()</code> 函数 umap dma buffer。例如：在 DMA 完成传输后会通过中断通知 cpu，而在中断函数中可以调用<code>dma_unmap_page()</code> 函数。</p><h4 id="dma-map-sg"><a href="#dma-map-sg" class="headerlink" title="dma_map_sg"></a>dma_map_sg</h4><p>在 scatterlist 的情况下，你要映射的对象是分散的若干段 DMA buffer，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i, count = dma_map_sg(dev, sglist, nents, direction);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scatterlist</span> *<span class="hljs-title">sg</span>;</span><br><br>for_each_sg(sglist, sg, count, i) &#123;<br>    hw_address[i] = sg_dma_address(sg);<br>    hw_len[i] = sg_dma_len(sg);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>nents</code> 说明了 sglist 中条目的数量（即 map 多少段 dma buffer）。</p><p>具体 DMA 映射的实现是自由的，它可以把 scatterlist 中的若干段连续的 DMA buffer 映射成一个大块的，连续的总线地址空间。例如：如果 DMA mapping 是以 PAGE_SIZE 为粒度进行映射，那么那些分散的一块块的 dma buffer 可以被映射到一个对齐在 PAGE_SIZE 上，然后各个 dma buffer 依次首尾相接在一个大的总线地址区域上。这样做的好处就是对于那些不支持（或者支持有限）scatter-gather 的 DMA controller，仍然可以通过 mapping 来实现。<code>dma_map_sg</code> 调用失败的时候返回 0，当调用成功的时候，返回成功mapping 的数目。</p><p>一旦调用成功，你需要调用 <code>for_each_sg</code> 来遍历所有成功映射的 mappings（这个数目可能会小于 <code>nents</code>）并且使用 <code>sg_dma_address()</code> 和 <code>sg_dma_len()</code> 这两个宏来得到 mapping 后的 dma 地址和长度。</p><p>umap 一个 scatterlist：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_unmap_sg(dev, sglist, nents, direction);<br></code></pre></td></tr></table></figure><p>再次强调，调用 <code>dma_unmap_sg</code> 的时候要确保 DMA 操作已经完成。</p><p>另外，传递给 <code>dma_unmap_sg</code> 的 <code>nents</code> 参数需要等于传递给 <code>dma_map_sg</code> 的 <code>nents</code>参数，而不是该函数返回的 <code>count</code>。</p><p>由于 DMA 地址空间是共享资源，每一次 <code>dma_map_&#123;single,sg&#125;()</code> 的调用都需要有其对应的 <code>dma_unmap_&#123;single,sg&#125;()</code>，如果你总是分配 dma 地址资源而不回收，那么系统将会由于 DMA address 被用尽而陷入不可用的状态。</p><h5 id="dma-sync-xxx"><a href="#dma-sync-xxx" class="headerlink" title="dma_sync_xxx"></a>dma_sync_xxx</h5><p>如果你需要多次访问同一个 streaming DMA buffer，并且在 DMA 传输之间读写 DMA Buffer 上的数据，这时候你需要小心进行 DMA buffer 的 sync 操作，以便 cpu 和设备可以看到最新的、正确的数据。</p><p>首先用 <code>dma_map_&#123;single,sg&#125;()</code> 进行映射，在完成 DMA 传输之后，需要调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_single_for_cpu(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_sg_for_cpu(dev, sglist, nents, direction);<br></code></pre></td></tr></table></figure><p>如果，cpu 操作了 DMA buffer 的数据，然后你又想把控制权交给设备上的 DMA 控制器，让 DMA controller 访问 DMA buffer，这时候，在真正让HW（指DMA控制器）去访问DMA buffer之前，你需要调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_single_for_device(dev, dma_handle, size, direction);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_sync_sg_for_device(dev, sglist, nents, direction);<br></code></pre></td></tr></table></figure><p>为了让 device 可以看到 cpu 更新后的数据。此外，需要强调的是：传递给<code>dma_sync_sg_for_cpu()</code> 和 <code>dma_sync_sg_for_device()</code> 的 <code>ents</code> 参数需要等于传递给 <code>dma_map_sg</code> 的 <code>nents</code> 参数，而不是该函数返回的 <code>count</code>。</p><p>在完成最后一次 DMA 传输之后，你需要调用 DMA unmap 函数 <code>dma_unmap_&#123;single,sg&#125;()</code>。</p><p>如果在第一次调用 <code>dma_map_*()</code> 和 <code>dma_unmap_*()</code> 之间，你从来都没有碰过 DMA buffer 中的数据，那么你根本不需要调用 <code>dma_sync_*()</code> 这样的 sync 操作。</p><p>下面的伪代码显示了需要使用 <code>dma sync *()</code> 接口的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c">my_card_setup_receive_buffer(<span class="hljs-keyword">struct</span> my_card *cp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)<br>&#123;<br>    <span class="hljs-type">dma_addr_t</span> mapping;<br><br>    mapping = dma_map_single(cp-&gt;dev, buffer, len, DMA_FROM_DEVICE);<br>    <span class="hljs-keyword">if</span> (dma_mapping_error(cp-&gt;dev, mapping)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * reduce current DMA mapping usage,</span><br><span class="hljs-comment">         * delay and try again later or</span><br><span class="hljs-comment">         * reset driver.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">goto</span> map_error_handling;<br>    &#125;<br><br>    cp-&gt;rx_buf = buffer;<br>    cp-&gt;rx_len = len;<br>    cp-&gt;rx_dma = mapping;<br><br>    give_rx_buf_to_card(cp);<br>&#125;<br><br>...<br><br>my_card_interrupt_handler(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *devid, <span class="hljs-keyword">struct</span> pt_regs *regs)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_card</span> *<span class="hljs-title">cp</span> =</span> devid;<br><br>    ...<br>    <span class="hljs-keyword">if</span> (read_card_status(cp) == RX_BUF_TRANSFERRED) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_card_header</span> *<span class="hljs-title">hp</span>;</span><br><br>        <span class="hljs-comment">/* Examine the header to see if we wish</span><br><span class="hljs-comment">         * to accept the data.  But synchronize</span><br><span class="hljs-comment">         * the DMA transfer with the CPU first</span><br><span class="hljs-comment">         * so that we see updated contents.</span><br><span class="hljs-comment">         */</span><br>        dma_sync_single_for_cpu(&amp;cp-&gt;dev, cp-&gt;rx_dma,<br>                    cp-&gt;rx_len,<br>                    DMA_FROM_DEVICE);<br><br>        <span class="hljs-comment">/* Now it is safe to examine the buffer. */</span><br>        hp = (<span class="hljs-keyword">struct</span> my_card_header *) cp-&gt;rx_buf;<br>        <span class="hljs-keyword">if</span> (header_is_ok(hp)) &#123;<br>            dma_unmap_single(&amp;cp-&gt;dev, cp-&gt;rx_dma, cp-&gt;rx_len,<br>                     DMA_FROM_DEVICE);<br>            pass_to_upper_layers(cp-&gt;rx_buf);<br>            make_and_setup_new_rx_buf(cp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/* CPU should not write to</span><br><span class="hljs-comment">             * DMA_FROM_DEVICE-mapped area,</span><br><span class="hljs-comment">             * so dma_sync_single_for_device() is</span><br><span class="hljs-comment">             * not needed here. It would be required</span><br><span class="hljs-comment">             * for DMA_BIDIRECTIONAL mapping if</span><br><span class="hljs-comment">             * the memory was modified.</span><br><span class="hljs-comment">             */</span><br>            give_rx_buf_to_card(cp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当使用了这套 DMA mapping 接口后，驱动不应该再使用 <code>virt_to_bus()</code> 这个接口了，当然 <code>bus_to_virt()</code> 也不行。不过，如果你的驱动使用了这些接口怎么办呢？其实这套新的 DMA mapping 接口没有和 <code>virt_to_bus</code>、<code>bus_to_virt()</code>一一对应的接口，因此，为了让你的程序能工作，你需要对驱动程序进行小小的修改：你必须要保存从<code>dma_alloc_coherent()</code>、<code>dma_pool_alloc() </code>以及 <code>dma_map_single()</code> 接口函数返回的 dma 地址（对于 <code>dma_map_sg()</code> 这个接口，dma 地址保存在 scatterlist 中，当然这需要硬件支持 dynamic DMA mapping ）,并把这个 dma 地址保存在驱动的数据结构中，并且同时&#x2F;或者保存在硬件的寄存器中。</p><p>所有的驱动代码都需要迁移到 DMA mapping framework 的接口函数上来。目前内核已经计划完全移除 <code>virt_to_bus()</code> 和 <code>bus_to_virt()</code> 这两个函数，因为它们已经过时了。有些平台由于不能正确的支持 <code>virt_to_bus()</code> 和 <code>bus_to_virt()</code>，因此根本就没有提供这两个接口。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>DMA 地址空间在某些 cpu 架构上是有限的，因此分配并映射可能会产生错误，我们可以通过下面的方法来判定是否发生了错误：</p><ul><li><p>检查是否 <code>dma_alloc_coherent()</code> 返回了 <code>NULL</code> 或者 <code>dma_map_sg</code> 返回 0</p></li><li><p>通过 <code>dma_mapping_error</code> 函数检查 <code>dma_map_single</code> 和 <code>dma_map_page</code> 返回的 dma 地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle;<br><br>dma_handle = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当在 mapping 多个 page 的时候，如果中间发生了 <code>mapping error</code>，那么需要对那些已经 mapped 的 page 进行 unmap 的操作。下面的示例代码用 <code>dma_map_single</code>函数，对于 <code>dma_map_page</code> 也一样适用。</p><p>示例一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle1;<br><span class="hljs-type">dma_addr_t</span> dma_handle2;<br><br>dma_handle1 = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle1)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling1;<br>&#125;<br>dma_handle2 = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle2)) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * reduce current DMA mapping usage,</span><br><span class="hljs-comment">     * delay and try again later or</span><br><span class="hljs-comment">     * reset driver.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">goto</span> map_error_handling2;<br>&#125;<br><br>...<br><br>map_error_handling2:<br>    dma_unmap_single(dma_handle1);<br>map_error_handling1:<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * if buffers are allocated in a loop, unmap all mapped buffers when</span><br><span class="hljs-comment"> * mapping error is detected in the middle</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">dma_addr_t</span> dma_addr;<br><span class="hljs-type">dma_addr_t</span> <span class="hljs-built_in">array</span>[DMA_BUFFERS];<br><span class="hljs-type">int</span> save_index = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; DMA_BUFFERS; i++) &#123;<br><br>    ...<br><br>    dma_addr = dma_map_single(dev, addr, size, direction);<br>    <span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_addr)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * reduce current DMA mapping usage,</span><br><span class="hljs-comment">         * delay and try again later or</span><br><span class="hljs-comment">         * reset driver.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">goto</span> map_error_handling;<br>    &#125;<br>    <span class="hljs-built_in">array</span>[i].dma_addr = dma_addr;<br>    save_index++;<br>&#125;<br><br>...<br><br>map_error_handling:<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; save_index; i++) &#123;<br><br>    ...<br><br>    dma_unmap_single(<span class="hljs-built_in">array</span>[i].dma_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在网卡驱动的 transmit 回调函数（例如 <code>ndo_start_xmit</code>）中出现了 DMA mapping 失败，那么驱动必须调用 <code>dev_kfree_skb()</code> 来释放 socket buffer 并返回<code>NETDEV_TX_OK</code> 。这表示这个 socket buffer 由于错误而丢弃掉了。</p><p>如果在 SCSI 驱动的 <code>queuecommand</code> 回调函数中出现了 DMA mapping 失败，那么驱动必须返回 <code>SCSI_MLQUEUE_HOST_BUSY</code> 。这意味着 SCSI 子系统稍后会再次重传该 command 给驱动。</p></li></ul><h4 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h4><p>在很多的平台上，<code>dma_unmap_&#123;single,page&#125;()</code> 其实什么也没有做，是空函数。因此，跟踪映射的 dma 地址及其长度基本上就是浪费内存空间。为了方便驱动工程师编写代码方便，我们提供了几个实用工具（宏定义），如果没有它们，驱动程序中将充分 <code>ifdef</code>或者类似的一些 “work around”。</p><p>下面我们并不是一个个的介绍这些宏定义，而是给出一些示例代码：</p><ul><li><p><code>DEFINE_DMA_UNMAP_&#123;ADDR,LEN&#125;</code>。在 DMA buffer 数据结构中使用这个宏定义，具体例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">before:<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ring_state</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *<span class="hljs-title">skb</span>;</span><br>    <span class="hljs-type">dma_addr_t</span> mapping;<br>    __u32 len;<br>&#125;;<br><br>after::<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ring_state</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *<span class="hljs-title">skb</span>;</span><br>    DEFINE_DMA_UNMAP_ADDR(mapping);<br>    DEFINE_DMA_UNMAP_LEN(len);<br>&#125;;<br></code></pre></td></tr></table></figure><p>根据 <code>CONFIG_NEED_DMA_MAP_STATE</code> 的配置不同，<code>DEFINE_DMA_UNMAP_&#123;ADDR,LEN&#125;</code>可能是定义相关的 dma 地址和长度的成员，也可能是空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NEED_DMA_MAP_STATE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_ADDR(ADDR_NAME)        dma_addr_t ADDR_NAME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_LEN(LEN_NAME)          __u32 LEN_NAME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr(PTR, ADDR_NAME)           ((PTR)-&gt;ADDR_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr_set(PTR, ADDR_NAME, VAL)  (((PTR)-&gt;ADDR_NAME) = (VAL))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len(PTR, LEN_NAME)             ((PTR)-&gt;LEN_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len_set(PTR, LEN_NAME, VAL)    (((PTR)-&gt;LEN_NAME) = (VAL))</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_ADDR(ADDR_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DMA_UNMAP_LEN(LEN_NAME)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr(PTR, ADDR_NAME)           (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_addr_set(PTR, ADDR_NAME, VAL)  do &#123; &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len(PTR, LEN_NAME)             (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dma_unmap_len_set(PTR, LEN_NAME, VAL)    do &#123; &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>dma_unmap_&#123;addr,len&#125;_set()</code> 来设置这些值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">before::<br><br>ringp-&gt;mapping = FOO;<br>ringp-&gt;len = BAR;<br><br>after::<br><br>dma_unmap_addr_set(ringp, mapping, FOO);<br>dma_unmap_len_set(ringp, len, BAR);<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>dma_unmap_&#123;addr,len&#125;()</code> 来访问这些值</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">before::<br><br>dma_unmap_single(dev, ringp-&gt;mapping, ringp-&gt;len,<br>         DMA_FROM_DEVICE);<br><br>after::<br><br>dma_unmap_single(dev,<br>         dma_unmap_addr(ringp, mapping),<br>         dma_unmap_len(ringp, len),<br>         DMA_FROM_DEVICE);<br></code></pre></td></tr></table></figure><p>  上面的这些代码基本是不需要解释你就会明白的了。另外，我们对于 dma address 和 len 是分开处理的，因为在有些实现中，unmaping 的操作仅仅需要 dma address 信息就够了。</p><h4 id="平台问题"><a href="#平台问题" class="headerlink" title="平台问题"></a>平台问题</h4><p>如果你仅仅是驱动工程师，并不负责将 linux 迁移到某个 cpu arch上去，那么后面的内容其实你可以忽略了。</p><ul><li><p><code>Struct scatterlist</code> 的需求</p><p>如果处理器架构支持 IOMMU（包括软件模拟的 IOMMU），那么你需要打开 <code>CONFIG_NEED_SG_DMA_LENGTH</code> 这个内核选项</p></li><li><p>ARCH_DMA_MINALIGN</p><p>cpu 体系结构相关的代码必须要要保证 <code>kmalloc</code> 分配的 buffer 是 DMA-safe 的（<code>kmalloc</code> 分配的 buffer 也是有可能用于 DMA buffer），驱动和内核子系统的正确运行都是依赖这个条件的。如果一个处理器架构不是全面支持 DMA-coherent 的（例如硬件并不保证 cpu cache 中的数据等于 main memory 中的数据），那么必须定义<code>ARCH_DMA_MINALIGN</code>。而通过这个宏定义，<code>kmalloc </code>分配的 buffer 可以保证对齐在 ARCH_DMA_MINALIGN上，从而保证了 <code>kmalloc </code>分配的 DMA Buffer 不会和其他的 buffer 共享一个 cacheline。想要了解具体的实例可以参考 <code>arch/arm/include/asm/cache.h</code>。</p><p>另外，请注意：<code>ARCH_DMA_MINALIGN</code> 是 DMA buffer 的对齐约束，你不需要担心处理器架构的数据对齐约束（例如，有些处理器架构要求有些数据对象需要 64 位对齐）。</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>如果没有无数个人的反馈和建议，本文档和 API 本身就不会有现在的形式。我们要特别提到以下几位人士，不分先后：</p><blockquote><p>Russell King <a href="mailto:&#114;&#109;&#107;&#x40;&#97;&#114;&#109;&#46;&#108;&#105;&#x6e;&#x75;&#x78;&#x2e;&#111;&#x72;&#x67;&#x2e;&#x75;&#107;">&#114;&#109;&#107;&#x40;&#97;&#114;&#109;&#46;&#108;&#105;&#x6e;&#x75;&#x78;&#x2e;&#111;&#x72;&#x67;&#x2e;&#x75;&#107;</a><br>Leo Dagum <a href="mailto:&#100;&#x61;&#x67;&#117;&#x6d;&#x40;&#98;&#97;&#x72;&#x72;&#101;&#108;&#x2e;&#101;&#110;&#103;&#114;&#46;&#115;&#103;&#x69;&#x2e;&#99;&#111;&#109;">&#100;&#x61;&#x67;&#117;&#x6d;&#x40;&#98;&#97;&#x72;&#x72;&#101;&#108;&#x2e;&#101;&#110;&#103;&#114;&#46;&#115;&#103;&#x69;&#x2e;&#99;&#111;&#109;</a><br>Ralf Baechle <a href="mailto:&#x72;&#97;&#x6c;&#102;&#x40;&#x6f;&#x73;&#x73;&#x2e;&#115;&#103;&#105;&#46;&#99;&#111;&#109;">&#x72;&#97;&#x6c;&#102;&#x40;&#x6f;&#x73;&#x73;&#x2e;&#115;&#103;&#105;&#46;&#99;&#111;&#109;</a><br>Grant Grundler <a href="mailto:&#x67;&#114;&#x75;&#110;&#100;&#108;&#101;&#114;&#x40;&#99;&#x75;&#112;&#x2e;&#x68;&#112;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#114;&#x75;&#110;&#100;&#108;&#101;&#114;&#x40;&#99;&#x75;&#112;&#x2e;&#x68;&#112;&#46;&#x63;&#x6f;&#x6d;</a><br>Jay Estabrook <a href="mailto:&#74;&#97;&#121;&#46;&#69;&#x73;&#x74;&#97;&#98;&#x72;&#111;&#111;&#107;&#64;&#99;&#x6f;&#x6d;&#112;&#x61;&#113;&#x2e;&#99;&#111;&#109;">&#74;&#97;&#121;&#46;&#69;&#x73;&#x74;&#97;&#98;&#x72;&#111;&#111;&#107;&#64;&#99;&#x6f;&#x6d;&#112;&#x61;&#113;&#x2e;&#99;&#111;&#109;</a><br>Thomas Sailer <a href="mailto:&#x73;&#97;&#x69;&#x6c;&#x65;&#x72;&#x40;&#105;&#x66;&#x65;&#x2e;&#x65;&#x65;&#46;&#x65;&#x74;&#104;&#x7a;&#46;&#x63;&#x68;">&#x73;&#97;&#x69;&#x6c;&#x65;&#x72;&#x40;&#105;&#x66;&#x65;&#x2e;&#x65;&#x65;&#46;&#x65;&#x74;&#104;&#x7a;&#46;&#x63;&#x68;</a><br>Andrea Arcangeli <a href="mailto:&#97;&#110;&#100;&#x72;&#x65;&#97;&#x40;&#x73;&#117;&#x73;&#x65;&#x2e;&#x64;&#101;">&#97;&#110;&#100;&#x72;&#x65;&#97;&#x40;&#x73;&#117;&#x73;&#x65;&#x2e;&#x64;&#101;</a><br>Jens Axboe <a href="mailto:&#x6a;&#x65;&#110;&#115;&#46;&#97;&#120;&#x62;&#x6f;&#101;&#x40;&#111;&#x72;&#x61;&#99;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x6a;&#x65;&#110;&#115;&#46;&#97;&#120;&#x62;&#x6f;&#101;&#x40;&#111;&#x72;&#x61;&#99;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a><br>David Mosberger-Tang <a href="mailto:&#100;&#x61;&#x76;&#105;&#100;&#109;&#64;&#x68;&#x70;&#108;&#46;&#104;&#112;&#x2e;&#99;&#x6f;&#109;">&#100;&#x61;&#x76;&#105;&#100;&#109;&#64;&#x68;&#x70;&#108;&#46;&#104;&#112;&#x2e;&#99;&#x6f;&#109;</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/08/linux/kernel/memory/arm64%20%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84/"/>
    <url>/2023/10/08/linux/kernel/memory/arm64%20%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="arm64-页表映射"><a href="#arm64-页表映射" class="headerlink" title="arm64 页表映射"></a>arm64 页表映射</h1><span id="more"></span><p>对于 ARM64 架构来说，目前基于 ARMv8-A 架构的处理器最大可以支持到 48 根地址线，也就是寻址 2^48 的虚拟地址空间，即虚拟地址空间范围为 0x0000000000000000～0x0000FFFFFFFFFFFF，共 256TB。其实完全可以做到 64 根地址线，那么最大就可以寻找到 2^64 的虚拟地址空间。但是对于目前的应用来说，256TB 的虚拟地址空间已经足够<br>使用了。因为如果支持 64 位虚拟地址空间，意味着处理器设计需要考虑更多的地址线，CPU 的设计复杂度会增大。<br>基于 ARMv8-A 架构的处理器的虚拟地址分成两个区域。分别是：</p><ul><li>0x0000000000000000 ~ 0x0000FFFFFFFFFFFF</li><li>0xFFFF000000000000 ~ 0xFFFFFFFFFFFFFFFF</li></ul><p>我们可以通过配置 CONFIG_ARM64_VA_BITS 宏来设置虚拟地址的宽度 </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">config ARM64_VA_BITS<br>int<br>default 36 if ARM64_VA_BITS_36<br>default 39 if ARM64_VA_BITS_39<br>default 42 if ARM64_VA_BITS_42<br>default 47 if ARM64_VA_BITS_47<br>default 48 if ARM64_VA_BITS_48 || ARM64_USER_VA_BITS_52<br></code></pre></td></tr></table></figure><p>而物理地址最大支持也是 48 位</p><p>Linux 内存空间布局与地址映射的粒度和地址映射的层级有关。处理器支持的页面大小有 4KB、 16KB、64KB，映射的层级可以是 3 级或者 4 级</p><p>我的 qemu 的配置为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_PGTABLE_LEVELS=4<br>CONFIG_ARM64_4K_PAGES=y<br>CONFIG_ARM64_VA_BITS_48=y<br>CONFIG_ARM64_VA_BITS=48<br>CONFIG_ARM64_PA_BITS_48=y<br>CONFIG_ARM64_PA_BITS=48<br></code></pre></td></tr></table></figure><p>见 <code>Documentation/arm64/memory.txt</code></p><p>该文档描述了 AArch64 Linux内核使用的虚拟内存布局。该体系结构允许最多 4 个级别的页表翻译，页面大小为4KB，以及最多 3 个级别的页表翻译，页面大小为 64 KB。</p><p>AArch6 使用 3 级或 4 级页表和 4KB 页配置，分别为用户和内核提供 39位(512GB) 或 48位(256TB) 虚拟地址。对于 64KB 的页面，只使用 2 层页表，允许使用 42 位(4TB) 虚拟地址，但是内存布局是相同的。</p><p>用户地址将 63:48 位设置为 0，而内核地址将相同的位设置为 1。TTBRx 选择由虚拟地址的第 63 位给出。<code>swapper_pg_dir</code> 只包含内核(全局)映射，而用户 PGD 只包含用户(非全局)映射。<code>swapper_pg_dir</code> 目录地址被写入到 TTBR1，而从未写入到 TTBR0，用户 PGD 页表首地址会写入 TTBR0</p><p>页表为 4KB，3 级页表，地址为 39 位的内存分布图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">AArch64 Linux memory layout with <span class="hljs-number">4</span>KB pages + <span class="hljs-number">3</span> levels：<br><br>StartEndSizeUse<br>-----------------------------------------------------------------------<br><span class="hljs-number">0000000000000000</span><span class="hljs-number">0000007f</span>ffffffff <span class="hljs-number">512</span>GBuser<br>ffffff8000000000ffffffffffffffff <span class="hljs-number">512</span>GBkernel<br></code></pre></td></tr></table></figure><p>页表为 4KB，4 级页表，地址为 48 位的内存分布图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">AArch64 Linux memory layout with <span class="hljs-number">4</span>KB pages + <span class="hljs-number">4</span> levels:<br><br>StartEndSizeUse<br>-----------------------------------------------------------------------<br><span class="hljs-number">0000000000000000</span><span class="hljs-number">0000f</span>fffffffffff <span class="hljs-number">256</span>TBuser<br>ffff000000000000ffffffffffffffff <span class="hljs-number">256</span>TBkernel<br></code></pre></td></tr></table></figure><p>页表为 64KB，2 级页表，地址为 42 位的内存分布图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">AArch64 Linux memory layout with <span class="hljs-number">64</span>KB pages + <span class="hljs-number">2</span> levels:<br><br>StartEndSizeUse<br>-----------------------------------------------------------------------<br><span class="hljs-number">0000000000000000</span><span class="hljs-number">000003f</span>fffffffff   <span class="hljs-number">4</span>TBuser<br>fffffc0000000000ffffffffffffffff   <span class="hljs-number">4</span>TBkernel<br></code></pre></td></tr></table></figure><p>页表为 64KB，3 级页表，地址为 48 位的内存分布图<a id="内存分布图"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">AArch64 Linux memory layout with <span class="hljs-number">64</span>KB pages + <span class="hljs-number">3</span> levels:<br><br>StartEndSizeUse<br>-----------------------------------------------------------------------<br><span class="hljs-number">0000000000000000</span><span class="hljs-number">0000f</span>fffffffffff <span class="hljs-number">256</span>TBuser<br>ffff000000000000ffffffffffffffff <span class="hljs-number">256</span>TBkernel<br></code></pre></td></tr></table></figure><p>下面的页表查询过程对应的内存布局图是<a href="#内存分布图">这里</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Translation table lookup with <span class="hljs-number">64</span>KB pages:<br><br>+--------+--------+--------+--------+--------+--------+--------+--------+<br>|<span class="hljs-number">63</span>    <span class="hljs-number">56</span>|<span class="hljs-number">55</span>    <span class="hljs-number">48</span>|<span class="hljs-number">47</span>    <span class="hljs-number">40</span>|<span class="hljs-number">39</span>    <span class="hljs-number">32</span>|<span class="hljs-number">31</span>    <span class="hljs-number">24</span>|<span class="hljs-number">23</span>    <span class="hljs-number">16</span>|<span class="hljs-number">15</span>     <span class="hljs-number">8</span>|<span class="hljs-number">7</span>      <span class="hljs-number">0</span>|<br>+--------+--------+--------+--------+--------+--------+--------+--------+<br> |                 |    |               |              |<br> |                 |    |               |              v<br> |                 |    |               |            [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]  in-page offset<br> |                 |    |               +----------&gt; [<span class="hljs-number">28</span>:<span class="hljs-number">16</span>] L3 index<br> |                 |    +--------------------------&gt; [<span class="hljs-number">41</span>:<span class="hljs-number">29</span>] L2 index<br> |                 +-------------------------------&gt; [<span class="hljs-number">47</span>:<span class="hljs-number">42</span>] L1 index<br> +-------------------------------------------------&gt; [<span class="hljs-number">63</span>] TTBR0/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>下面的页表查询过程对应的内存布局图是[这里](#页表为 4KB，4 级页表，地址为 48 位的内存分布图)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">Translation table lookup with <span class="hljs-number">4</span>KB pages:<br><br>+--------+--------+--------+--------+--------+--------+--------+--------+<br>|<span class="hljs-number">63</span>    <span class="hljs-number">56</span>|<span class="hljs-number">55</span>    <span class="hljs-number">48</span>|<span class="hljs-number">47</span>    <span class="hljs-number">40</span>|<span class="hljs-number">39</span>    <span class="hljs-number">32</span>|<span class="hljs-number">31</span>    <span class="hljs-number">24</span>|<span class="hljs-number">23</span>    <span class="hljs-number">16</span>|<span class="hljs-number">15</span>     <span class="hljs-number">8</span>|<span class="hljs-number">7</span>      <span class="hljs-number">0</span>|<br>+--------+--------+--------+--------+--------+--------+--------+--------+<br> |                 |         |         |         |         |<br> |                 |         |         |         |         v<br> |                 |         |         |         |   [<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]  in-page offset<br> |                 |         |         |         +-&gt; [<span class="hljs-number">20</span>:<span class="hljs-number">12</span>] L3 index<br> |                 |         |         +-----------&gt; [<span class="hljs-number">29</span>:<span class="hljs-number">21</span>] L2 index<br> |                 |         +---------------------&gt; [<span class="hljs-number">38</span>:<span class="hljs-number">30</span>] L1 index<br> |                 +-------------------------------&gt; [<span class="hljs-number">47</span>:<span class="hljs-number">39</span>] L0 index<br> +-------------------------------------------------&gt; [<span class="hljs-number">63</span>] TTBR0/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们目前使用的是这种，kernel 源码文档中没怎么对齐，可以看下面的图</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309212116358.png" alt="image-20230921211640317"></p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309212115515.png" alt="image-20230921211545326"></p><ul><li>如果虚拟地址最高位 bit[63]为 1，那么这个地址是用于内核空间的，页表的基地址寄存器用 TTBR1_EL1。如果 bit[63]等于 0，这个虚拟地址属于用户空间，页表基地址寄存器用 TTBR0。</li><li>TTBRx 寄存器保存了第 0 级页表的基地址（ L0 Table base address， Linux 内核中称为 PGD），其中有 512 个页表项，以虚拟地址的 bit[47:39] 作为索引值在 L0 页表中查找相应的页表项。每个表项的内容含有下一级页表的物理基地址，即 L1 页表（ Linux 内核中称为 PUD）的基地址。</li><li>PUD 页表中有 512 个页表项，以虚拟地址的 bit[38:30]为索引值在 PUD 表中查找相应的表项，每个表项的内容含有下一级页表的物理基地址，即 L2 页表（Linux 内核中称为 PMD）的基地址。</li><li>PMD 页表中有 512 个表项，以虚拟地址的 bit[29:21]为索引值在 PMD 表中查找相应的表项，每个表项的内容含有下一级页表的物理基地址，即 L3 页表（ Linux 内核中称为 PTE）的基地址。</li><li>在 PTE 页表中，以虚拟地址的 bit[20:12]为索引值在 PTE 表中查找相应的表项，每个 PTE 表项中含有最终的物理地址的 bit[47:12]，和虚拟地址中 bit[11:0]合并成最终的物理地址，完成地址翻译过程。</li></ul><p>在内核初始化阶段会 <code>__create_pgd_mapping</code> 对内核空间的页表进行一一映射（<code>arch/arm64/mm/mmu.c</code>）</p><p><code>start_kenrel-&gt; setup_arch-&gt;paging_init-&gt;map_mem-&gt;__map_memblock-&gt;__create_pgd_mapping</code></p><p>首先来看一下 <code>paging_init</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">paging_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">pgd_t</span> *pgdp = pgd_set_fixmap(__pa_symbol(swapper_pg_dir));<br>map_kernel(pgdp);<br>map_mem(pgdp);<br>pgd_clear_fixmap();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map_kernel</code>：对内核映像文件的各段重新映射，之前在汇编中对齐做了块映射，现在要重新进行细粒度的页面映射了</p><p><code>map_mem</code>: 对所有物理内存的线性映射，因为现在虚拟内核空间足够大，可以全部线性映射。物理内存会全部线性映射到 PAGE_OFFSET 开始的内核空间的虚拟地址，以加快内核访问内存（无需 mmu 查询多级页表）</p><p>再调用 <code>__create_pgd_mapping</code> 函数之前需要获取内核 PGD 页表首地址。在内存线性映射完成之前是不能使用 <code>__pa()</code> 将虚拟地址线性转换成物理地址的</p><p><code>swapper_pg_dir</code> 是内核 PGD 页表虚拟基地址，之前在汇编阶段也有一个内核 PGD 页表是 <code>init_pg_dir</code>，它只是做了简单的粗粒度的块映射，这次 <code>swapper_pg_dir</code> 是要做细粒度，如 4KB 的页表映射</p><p>可查看 System.map</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ffff000011be9000 T swapper_pg_dir<br></code></pre></td></tr></table></figure><p><code>__pa_symbol()</code> 宏是将内核映射的虚拟地址线性转换为物理地址，而这里还没有将物理内存线性映射到内核空间，所以不能使用 <code>__pa()</code>，那 <code>__pa_symbol</code> 是怎么转换的呢？我们看下</p><p><code>arch/arm64/include/asm/memory.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __kimg_to_phys(addr)((addr) - kimage_voffset)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa_symbol_nodebug(x)__kimg_to_phys((phys_addr_t)(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __phys_addr_symbol(x)__pa_symbol_nodebug(x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa_symbol(x)__phys_addr_symbol(RELOC_HIDE((unsigned long)(x), 0))</span><br></code></pre></td></tr></table></figure><p>可以看到最终是也是通过一种线性映射的方式转换的，偏移量为 <code>kimage_voffset</code>，这个在哪里设置的呢？它是在初级阶段汇编函数 <code>__primary_switched</code> 中设置的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__primary_switched:<br>...<br>ldr_lx4, kimage_vaddr<span class="hljs-comment">// Save the offset between</span><br>subx4, x4, x0<span class="hljs-comment">// the kernel virtual and</span><br>str_lx4, kimage_voffset, x5<span class="hljs-comment">// physical mappings</span><br></code></pre></td></tr></table></figure><p><code>x4</code> 是 <code>kimage_vaddr</code>，一看就是内核映像虚拟基地址</p><p><code>x0</code> 是在汇编函数 <code>__primary_switch</code> 中调用的时候传给 <code>__primary_switched</code> 的，值为 <code>__PHYS_OFFSET</code>，应该是内核映像物理基地址</p><p><code>kimage_voffset</code> 就是内核映像虚拟基地址 - 内核映像物理基地址</p><p>我们先看一下 <code>__PHYS_OFFSET</code> 是怎么得出的</p><p><code>arch/arm64/kernel/head.S</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#define __PHYS_OFFSET(KERNEL_START - TEXT_OFFSET)<br><br>__primary_switch:<br>#ifdef CONFIG_RANDOMIZE_BASE<br>ldrx8, =__primary_switched<br>adrpx0, __PHYS_OFFSET<br>blrx8<br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/memory.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNEL_START      _text</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/Makefile</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TEXT_OFFSET := 0x00080000<br></code></pre></td></tr></table></figure><p><code>arch/arm64/kernel/vmlinux.lds.S</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">. = KIMAGE_VADDR + TEXT_OFFSET;<br><br>.head.text : &#123;<br>_text = .;<br>HEAD_TEXT<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面可以看出 <code>__PHYS_OFFSET</code> 最终等于 <code>KIMAGE_VADDR</code>，即内核映像虚拟基地址，为什么是虚拟的？</p><p>前面确实已经开启了 MMU，而使用 <code>adrp</code> 指令获取到运行时地址确实就是虚拟地址，可我们这里需要的是物理地址呀，我们再仔细看上面写了 <code>.section &quot;.idmap.text&quot;,&quot;awx&quot;</code>，说明 <code>__primary_switch</code> 在恒等映射区，这里的虚拟地址等于物理地址，所以 <code>__PHYS_OFFSET</code> 就是内核映像的物理基地址了</p><p>我们在看一下 <code>kimage_vaddr</code></p><p><code>arch/arm64/kernel/head.S</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ENTRY(kimage_vaddr)<br>.quad_text - TEXT_OFFSET<br>EXPORT_SYMBOL(kimage_vaddr)<br></code></pre></td></tr></table></figure><p><code>kimage_vaddr</code> 就是 <code>KIMAGE_VADDR</code>，内核映像虚拟基地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * KIMAGE_VADDR - the virtual address of the start of the kernel image</span><br><span class="hljs-comment"> */</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KIMAGE_VADDR(MODULES_END)</span><br>...<br></code></pre></td></tr></table></figure><p>像我的 qemu，<code>KIMAGE_VADDR</code> 就是 0xffff000010000000，在 vmalloc 区间</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309221142941.png" alt="image-20230922114213903"></p><p><code>kimage_voffset</code> 就是 0xfffeffffd0000000</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309221139949.png" alt="image-20230922113937905"></p><p>所以在物理内存全部线性映射到内核空间之前可以用 <code>__pa_symbol</code> 宏，如果以后就可以用宏 <code>__pa</code>，我们看一下它的实现</p><p><code>arch/arm64/include/asm/memory.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __is_lm_address(addr)(!!((addr) &amp; BIT(VA_BITS - 1)))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __lm_to_phys(addr)(((addr) &amp; ~PAGE_OFFSET) + PHYS_OFFSET)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __virt_to_phys_nodebug(x) (&#123;\</span><br><span class="hljs-meta">phys_addr_t __x = (phys_addr_t)(x);\</span><br><span class="hljs-meta">__is_lm_address(__x) ? __lm_to_phys(__x) :\</span><br><span class="hljs-meta">       __kimg_to_phys(__x);\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __virt_to_phys(x)__virt_to_phys_nodebug(x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa(x)__virt_to_phys((unsigned long)(x))</span><br><br></code></pre></td></tr></table></figure><p>先调用 <code>__is_lm_address</code> 宏判断虚拟地址在哪个区域，如果线性映射区就调用 <code>__virt_to_phys</code>，否则就调用 <code>__kimg_to_phys</code></p><p>看下面这幅图就可以很好理解了</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309221149785.png" alt="image-20230922114949705"></p><p>然后再调用 <code>pgd_set_fixmap</code> 函数将 fixmap 区间 <code>PGD_INDEX</code> 位置的虚拟地址和 <code>swapper_pg_dir</code> 临时建立映射关系，方便访问，后面就会调用 <code>pgd_clear_fixmap</code> 取消映射了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __create_pgd_mapping(<span class="hljs-type">pgd_t</span> *pgdir, <span class="hljs-type">phys_addr_t</span> phys,<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> virt, <span class="hljs-type">phys_addr_t</span> size,<br> <span class="hljs-type">pgprot_t</span> prot,<br> <span class="hljs-type">phys_addr_t</span> (*pgtable_alloc)(<span class="hljs-type">void</span>),<br> <span class="hljs-type">int</span> flags)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, length, end, next;<br><span class="hljs-type">pgd_t</span> *pgdp = pgd_offset_raw(pgdir, virt);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the virtual and physical address don&#x27;t have the same offset</span><br><span class="hljs-comment"> * within a page, we cannot map the region as the caller expects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (WARN_ON((phys ^ virt) &amp; ~PAGE_MASK))<br><span class="hljs-keyword">return</span>;<br><br>phys &amp;= PAGE_MASK;<br>addr = virt &amp; PAGE_MASK;<br>length = PAGE_ALIGN(size + (virt &amp; ~PAGE_MASK));<br><br>end = addr + length;<br><span class="hljs-keyword">do</span> &#123;<br>next = pgd_addr_end(addr, end);<br>alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc,<br>       flags);<br>phys += next - addr;<br>&#125; <span class="hljs-keyword">while</span> (pgdp++, addr = next, addr != end);<br>&#125;<br></code></pre></td></tr></table></figure><p>后面的参数都是调用 <code>__map_memblock</code> 传入的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* map all the memory banks */</span><br>for_each_memblock(memory, reg) &#123;<br><span class="hljs-type">phys_addr_t</span> start = reg-&gt;base;<br><span class="hljs-type">phys_addr_t</span> end = start + reg-&gt;size;<br><br><span class="hljs-keyword">if</span> (start &gt;= end)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (memblock_is_nomap(reg))<br><span class="hljs-keyword">continue</span>;<br><br>__map_memblock(pgdp, start, end, PAGE_KERNEL, flags);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init __map_memblock(<span class="hljs-type">pgd_t</span> *pgdp, <span class="hljs-type">phys_addr_t</span> start,<br>  <span class="hljs-type">phys_addr_t</span> end, <span class="hljs-type">pgprot_t</span> prot, <span class="hljs-type">int</span> flags)<br>&#123;<br>__create_pgd_mapping(pgdp, start, __phys_to_virt(start), end - start,<br>     prot, early_pgtable_alloc, flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们统一列出所有参数</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>*pgdir</td><td><code>swapper_pg_dir</code> 虚拟地址，内核空间 PGD 页表</td></tr><tr><td>phys</td><td>每个 memblock 区间的物理首地址</td></tr><tr><td>virt</td><td>每个 memblock 区间的虚拟首地址</td></tr><tr><td>size</td><td>每个 memblock 区间大小</td></tr><tr><td>prot</td><td>页面的属性</td></tr><tr><td>(*pgtable_alloc)(void)</td><td>分配页表内存函数 <code>early_pgtable_alloc</code></td></tr><tr><td>flags</td><td>相关标志，如 NO_CONT_MAPPINGS、NO_BLOCK_MAPPINGS</td></tr></tbody></table><p>第 8 行，调用 <code>pgd_offset_raw</code> 得到 virt 在 pgd 页表中表项的位置</p><p><code>arch/arm64/include/asm/memory.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_USER_VA_BITSVA_BITS</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/pgtable-hwdef.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARM64_HW_PGTABLE_LEVEL_SHIFT(n)((PAGE_SHIFT - 3) * (4 - (n)) + 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGDIR_SHIFTARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTRS_PER_PGD(1 &lt;&lt; (MAX_USER_VA_BITS - PGDIR_SHIFT))</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/pgtable.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> pgd_index(addr)(((addr) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pgd_offset_raw(pgd, addr)((pgd) + pgd_index(addr))</span><br></code></pre></td></tr></table></figure><p>通过 <code>pgd_index</code> 可以得到 virt 在 pgd 页表中的偏移，再加上 pgd 页表虚拟首地址就是 virt 对应页表项的虚拟地址</p><p>如页表大小为 4KB，即 PAGE_SHIFT &#x3D; 12，4 级页表，即 CONFIG_PGTABLE_LEVELS &#x3D; 4，则 PGDIR_SHIFT &#x3D; ((12 - 3) * (4 - 0) + 3) &#x3D; 39，如虚拟地址宽度 VA_BITS 为 48，PGD 的页表项个数 PTRS_PER_PGD 为 1 &lt;&lt; (48 - 39) &#x3D; 2^9 &#x3D; 512</p><p>回到 <code>__create_pgd_mapping</code></p><p>第 17 行，物理地址按页对齐</p><p>第 18 行，虚拟地址也按也对齐</p><p>因为映射是整页映射的，所以必须对齐</p><p>第 19 行，计算出要映射的长度</p><p>第 21 行，计算出所映像范围的结束虚拟地址</p><p>第 22 ~ 27，以 <code>PGDIR_SIZE</code> 为步长遍历 [virt, virt+size] 内存区间，看这个区间需要多少个 PUD，然后就调用 <code>alloc_init_pud</code>()来分配 PUD 页表来填充对应的 PGD 页表项。</p><p>看一下 <code>pgd_addr_end</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> pgd_addr_end(addr, end)\</span><br><span class="hljs-meta">(&#123;unsigned long __boundary = ((addr) + PGDIR_SIZE) &amp; PGDIR_MASK;\</span><br><span class="hljs-meta">(__boundary - 1 &lt; (end) - 1)? __boundary: (end);\</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/pgtable-hwdef.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGDIR_SIZE(_AC(1, UL) &lt;&lt; PGDIR_SHIFT)</span><br></code></pre></td></tr></table></figure><p><code>PGDIR_SIZE</code> 表示一个 pgd 页表项可以映射的地址范围，还是上面的配置的话就是 2^39 &#x3D; 512 GB，<code>__boundary</code> 为下一个 pgd 页表项可以管理的地址范围的开始，如果 <code>__boundary</code> 大于 <code>end</code>，说明 1 个 pgd 页表项就够了，否则还得继续填充下一个 pgd 页表项</p><p>看一下 <code>alloc_init_pud</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">alloc_init_pud</span><span class="hljs-params">(<span class="hljs-type">pgd_t</span> *pgdp, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end,</span><br><span class="hljs-params">   <span class="hljs-type">phys_addr_t</span> phys, <span class="hljs-type">pgprot_t</span> prot,</span><br><span class="hljs-params">   <span class="hljs-type">phys_addr_t</span> (*pgtable_alloc)(<span class="hljs-type">void</span>),</span><br><span class="hljs-params">   <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next;<br><span class="hljs-type">pud_t</span> *pudp;<br><span class="hljs-type">pgd_t</span> pgd = READ_ONCE(*pgdp);<br><br><span class="hljs-keyword">if</span> (pgd_none(pgd)) &#123;<br><span class="hljs-type">phys_addr_t</span> pud_phys;<br>BUG_ON(!pgtable_alloc);<br>pud_phys = pgtable_alloc();<br>__pgd_populate(pgdp, pud_phys, PUD_TYPE_TABLE);<br>pgd = READ_ONCE(*pgdp);<br>&#125;<br>BUG_ON(pgd_bad(pgd));<br><br>pudp = pud_set_fixmap_offset(pgdp, addr);<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">pud_t</span> old_pud = READ_ONCE(*pudp);<br><br>next = pud_addr_end(addr, end);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For 4K granule only, attempt to put down a 1GB block</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (use_1G_block(addr, next, phys) &amp;&amp;<br>    (flags &amp; NO_BLOCK_MAPPINGS) == <span class="hljs-number">0</span>) &#123;<br>pud_set_huge(pudp, phys, prot);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * After the PUD entry has been populated once, we</span><br><span class="hljs-comment"> * only allow updates to the permission attributes.</span><br><span class="hljs-comment"> */</span><br>BUG_ON(!pgattr_change_is_safe(pud_val(old_pud),<br>      READ_ONCE(pud_val(*pudp))));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>alloc_init_cont_pmd(pudp, addr, next, phys, prot,<br>    pgtable_alloc, flags);<br><br>BUG_ON(pud_val(old_pud) != <span class="hljs-number">0</span> &amp;&amp;<br>       pud_val(old_pud) != READ_ONCE(pud_val(*pudp)));<br>&#125;<br>phys += next - addr;<br>&#125; <span class="hljs-keyword">while</span> (pudp++, addr = next, addr != end);<br><br>pud_clear_fixmap();<br>&#125;<br></code></pre></td></tr></table></figure><p>第 8 行，拿出 pgd 页表项的值</p><p>第 10 ~ 16 行，如果 pgd 页表项为空，就要分配一个新的页表</p><p>第 19 行，使用 fixmap 段的 <code>FIX_PUD</code> 的虚拟地址映射 virt 在 pud 对应页表项的物理地址，主要是为了方便使用虚拟指针来访问，后面会调用 <code>pud_clear_fixmap</code> 来解除映射</p><p>第 20 ~ 46 行，是以 <code>PUD_SIZE</code> 为步长来设置下一级的页表，和 pgd 一样，如果所要映射的地址范围大于 <code>PUD_SIZE</code>，就需要填充多个 pud 页表项</p><p><code>include/asm-generic/pgtable.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> pud_addr_end(addr, end)\</span><br><span class="hljs-meta">(&#123;unsigned long __boundary = ((addr) + PUD_SIZE) &amp; PUD_MASK;\</span><br><span class="hljs-meta">(__boundary - 1 &lt; (end) - 1)? __boundary: (end);\</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/pgtable-hwdef.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_SHIFTARM64_HW_PGTABLE_LEVEL_SHIFT(1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_SIZE(_AC(1, UL) &lt;&lt; PUD_SHIFT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_MASK(~(PUD_SIZE-1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTRS_PER_PUDPTRS_PER_PTE</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>PUD_SHIFT</code> &#x3D; (12 - 3) * (4 - 1) + 3 &#x3D; 30，所以一个 pud 页表项 <code>PUD_SIZE</code> 可以管理 2^30 &#x3D; 1GB 大小内存</p><p>第 28 行，<code>use_1G_block()</code> 函数会判断是否使用 1GB 大小的块映射？当这里要映射的大小内存块正好是 PUD_SIZE，那么只需要映射到 PUD 就好了</p><p>看 <code>pud_set_huge</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pud_set_huge</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> *pudp, <span class="hljs-type">phys_addr_t</span> phys, <span class="hljs-type">pgprot_t</span> prot)</span><br>&#123;<br><span class="hljs-type">pgprot_t</span> sect_prot = __pgprot(PUD_TYPE_SECT |<br>pgprot_val(mk_sect_prot(prot)));<br><span class="hljs-type">pud_t</span> new_pud = pfn_pud(__phys_to_pfn(phys), sect_prot);<br><br><span class="hljs-comment">/* Only allow permission changes for now */</span><br><span class="hljs-keyword">if</span> (!pgattr_change_is_safe(READ_ONCE(pud_val(*pudp)),<br>   pud_val(new_pud)))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>BUG_ON(phys &amp; ~PUD_MASK);<br>set_pud(pudp, new_pud);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第 5 行，将物理地址转为物理页帧号 pfn，然后和属性结合形成新的页表项值</p><p>第 13 行，将页表项值设置 pud 对应的页表项中</p><p>如果 <code>use_1G_block 函数判断不能通过 1GB 大小来映射， 那么就要调用  </code> alloc_init_cont_pmd 来进行下一级页表的映射了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">alloc_init_cont_pmd</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> *pudp, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end, <span class="hljs-type">phys_addr_t</span> phys,</span><br><span class="hljs-params"><span class="hljs-type">pgprot_t</span> prot,</span><br><span class="hljs-params"><span class="hljs-type">phys_addr_t</span> (*pgtable_alloc)(<span class="hljs-type">void</span>), <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next;<br><span class="hljs-type">pud_t</span> pud = READ_ONCE(*pudp);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check for initial section mappings in the pgd/pud.</span><br><span class="hljs-comment"> */</span><br>BUG_ON(pud_sect(pud));<br><span class="hljs-keyword">if</span> (pud_none(pud)) &#123;<br><span class="hljs-type">phys_addr_t</span> pmd_phys;<br>BUG_ON(!pgtable_alloc);<br>pmd_phys = pgtable_alloc();<br>__pud_populate(pudp, pmd_phys, PUD_TYPE_TABLE);<br>pud = READ_ONCE(*pudp);<br>&#125;<br>BUG_ON(pud_bad(pud));<br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">pgprot_t</span> __prot = prot;<br><br>next = pmd_cont_addr_end(addr, end);<br><br><span class="hljs-comment">/* use a contiguous mapping if the range is suitably aligned */</span><br><span class="hljs-keyword">if</span> ((((addr | next | phys) &amp; ~CONT_PMD_MASK) == <span class="hljs-number">0</span>) &amp;&amp;<br>    (flags &amp; NO_CONT_MAPPINGS) == <span class="hljs-number">0</span>)<br>__prot = __pgprot(pgprot_val(prot) | PTE_CONT);<br><br>init_pmd(pudp, addr, next, phys, __prot, pgtable_alloc, flags);<br><br>phys += next - addr;<br>&#125; <span class="hljs-keyword">while</span> (addr = next, addr != end);<br>&#125;<br></code></pre></td></tr></table></figure><p>第 7 行，得到 pud 页表项的值</p><p>第 13 ~ 19 行，如果 pud 页表项的值为空，就分配一个新的 pmd 页表，然后设置它</p><p>第 22 ~ 35 行，调用 <code>init_pmd</code> 来初始化 PT 和设置 PMD 页表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init_pmd</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> *pudp, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end,</span><br><span class="hljs-params">     <span class="hljs-type">phys_addr_t</span> phys, <span class="hljs-type">pgprot_t</span> prot,</span><br><span class="hljs-params">     <span class="hljs-type">phys_addr_t</span> (*pgtable_alloc)(<span class="hljs-type">void</span>), <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next;<br><span class="hljs-type">pmd_t</span> *pmdp;<br><br>pmdp = pmd_set_fixmap_offset(pudp, addr);<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">pmd_t</span> old_pmd = READ_ONCE(*pmdp);<br><br>next = pmd_addr_end(addr, end);<br><br><span class="hljs-comment">/* try section mapping first */</span><br><span class="hljs-keyword">if</span> (((addr | next | phys) &amp; ~SECTION_MASK) == <span class="hljs-number">0</span> &amp;&amp;<br>    (flags &amp; NO_BLOCK_MAPPINGS) == <span class="hljs-number">0</span>) &#123;<br>pmd_set_huge(pmdp, phys, prot);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * After the PMD entry has been populated once, we</span><br><span class="hljs-comment"> * only allow updates to the permission attributes.</span><br><span class="hljs-comment"> */</span><br>BUG_ON(!pgattr_change_is_safe(pmd_val(old_pmd),<br>      READ_ONCE(pmd_val(*pmdp))));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>alloc_init_cont_pte(pmdp, addr, next, phys, prot,<br>    pgtable_alloc, flags);<br><br>BUG_ON(pmd_val(old_pmd) != <span class="hljs-number">0</span> &amp;&amp;<br>       pmd_val(old_pmd) != READ_ONCE(pmd_val(*pmdp)));<br>&#125;<br>phys += next - addr;<br>&#125; <span class="hljs-keyword">while</span> (pmdp++, addr = next, addr != end);<br><br>pmd_clear_fixmap();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个主要做的是：</p><ul><li><p>以 <code>PMD_SIZE</code>(2^21 &#x3D; 2MB) 为步长，循环设置下一级页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_SHIFTARM64_HW_PGTABLE_LEVEL_SHIFT(2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_SIZE(_AC(1, UL) &lt;&lt; PMD_SHIFT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_MASK(~(PMD_SIZE-1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTRS_PER_PMDPTRS_PER_PTE</span><br></code></pre></td></tr></table></figure></li><li><p>如果起始虚拟地址、虚拟结束地址和物理起始地址与 <code>SECTION_MASK</code>(2MB) 对齐，那就是段映射，调用 <code>pmd_set_huge</code>，将物理地址和属性结合的新的页表项值直接设置到 pmd 表项中</p></li><li><p>如果不是段映射，那就要调用 <code>alloc_init_cont_pte</code> 来设置 PTE 页表</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">alloc_init_cont_pte</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> *pmdp, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end, <span class="hljs-type">phys_addr_t</span> phys,</span><br><span class="hljs-params"><span class="hljs-type">pgprot_t</span> prot,</span><br><span class="hljs-params"><span class="hljs-type">phys_addr_t</span> (*pgtable_alloc)(<span class="hljs-type">void</span>),</span><br><span class="hljs-params"><span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next;<br><span class="hljs-type">pmd_t</span> pmd = READ_ONCE(*pmdp);<br><br>BUG_ON(pmd_sect(pmd));<br><span class="hljs-keyword">if</span> (pmd_none(pmd)) &#123;<br><span class="hljs-type">phys_addr_t</span> pte_phys;<br>BUG_ON(!pgtable_alloc);<br>pte_phys = pgtable_alloc();<br>__pmd_populate(pmdp, pte_phys, PMD_TYPE_TABLE);<br>pmd = READ_ONCE(*pmdp);<br>&#125;<br>BUG_ON(pmd_bad(pmd));<br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">pgprot_t</span> __prot = prot;<br><br>next = pte_cont_addr_end(addr, end);<br><br><span class="hljs-comment">/* use a contiguous mapping if the range is suitably aligned */</span><br><span class="hljs-keyword">if</span> ((((addr | next | phys) &amp; ~CONT_PTE_MASK) == <span class="hljs-number">0</span>) &amp;&amp;<br>    (flags &amp; NO_CONT_MAPPINGS) == <span class="hljs-number">0</span>)<br>__prot = __pgprot(pgprot_val(prot) | PTE_CONT);<br><br>init_pte(pmdp, addr, next, phys, __prot);<br><br>phys += next - addr;<br>&#125; <span class="hljs-keyword">while</span> (addr = next, addr != end);<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数主要做的事是：</p><ul><li>如果 pmd 页表项为空，就分配一个新的 pte 页表，然后调用 <code>__pmd_populate</code> 设置到 pmd 表项中，可以看到属性中有 <code>PMD_TYPE_TABLE</code>，表示是页的表项，而不是段的表项</li><li><code>PTE_CONT</code> 连续页我们先不管</li><li>以 <code>PAGE_SIZE</code>，如 4KB 为步长，调用 <code>init_pte</code> 循环设置 PTE</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init_pte</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> *pmdp, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end,</span><br><span class="hljs-params">     <span class="hljs-type">phys_addr_t</span> phys, <span class="hljs-type">pgprot_t</span> prot)</span><br>&#123;<br><span class="hljs-type">pte_t</span> *ptep;<br><br>ptep = pte_set_fixmap_offset(pmdp, addr);<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">pte_t</span> old_pte = READ_ONCE(*ptep);<br><br>set_pte(ptep, pfn_pte(__phys_to_pfn(phys), prot));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * After the PTE entry has been populated once, we</span><br><span class="hljs-comment"> * only allow updates to the permission attributes.</span><br><span class="hljs-comment"> */</span><br>BUG_ON(!pgattr_change_is_safe(pte_val(old_pte),<br>      READ_ONCE(pte_val(*ptep))));<br><br>phys += PAGE_SIZE;<br>&#125; <span class="hljs-keyword">while</span> (ptep++, addr += PAGE_SIZE, addr != end);<br><br>pte_clear_fixmap();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数主要做的事是：</p><ul><li>调用 <code>set_pte</code> 将物理地址和属性结合成新的页表项，然后设置到 pte 中</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/08/linux/kernel/memory/%E9%A1%B5%E8%A1%A8/"/>
    <url>/2023/10/08/linux/kernel/memory/%E9%A1%B5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h1><span id="more"></span><h2 id="页表-1"><a href="#页表-1" class="headerlink" title="页表"></a>页表</h2><p>AArch64 架构支持两种页表转换模式</p><ul><li>单一阶段页表转换：把虚拟地址（VA）转换成物理地址（PA）</li><li>虚拟化扩展中的两阶段页表转换：<ul><li>阶段1：把虚拟地址（VA）转换成中间物理地址（IPA）</li><li>阶段2：把 IPA 转换成最终的物理地址 PA</li></ul></li></ul><p>ARMv8 支持多种页表格式：</p><ul><li>ARMv8 的长描述符页表格式</li><li>ARMv7 的长描述符页表格式，但是需要打开大物理地址扩展（LPAE）</li><li>ARMv7 的短描述符页表格式</li></ul><p>当使用 AArch32 处理器时，使用 ARMv7 的长或短描述符页表格式；当使用 AArch64 处理器时，使用 ARMv8 的长描述符页表格式。</p><p>ARMv8 支持 4KB、16KB、64KB 三种页面粒度</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202310081053632.png" alt="image-20231008105315579"></p><h2 id="页表项描述符"><a href="#页表项描述符" class="headerlink" title="页表项描述符"></a>页表项描述符</h2><p>AArch64 最多支持 4 级页表，每一级都有页表项，即页表项描述符。</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202310081058577.png" alt="image-20231008105820536"></p><p>因为 64 位，所以每个表项占 8 个字节。下面来看一下每一级页表表项的格式和内容：</p><h3 id="L0-L2-页表项描述符"><a href="#L0-L2-页表项描述符" class="headerlink" title="L0 ~ L2 页表项描述符"></a>L0 ~ L2 页表项描述符</h3><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202310081104341.png" alt="image-20231008110403299"></p><p>L0 ~ L2 页表项分为 3 种：</p><ul><li>当页表项描述的 bit[0] 为 1 时，表示有效描述符；当 bit[0] &#x3D; 0，表示无效描述符</li><li>页表项描述符 bit[1] 表示类型<ul><li>页表类型：当 bit[1] &#x3D; 1 时，bit[47:m] 存放指向下一个页表的物理基地址<ul><li>当页面粒度为 4KB 时，m &#x3D; 12</li><li>当页面粒度为 16KB 时，m &#x3D; 14</li><li>当页面粒度为 64KB 时，m &#x3D; 16</li></ul></li><li>块类型：当 bit[1] &#x3D; 0 时，bit[47:n] 存放最终的物理地址<ul><li>当页面粒度为 4KB，在 L1 页表项描述符种 n 为 30，表示 1GB 的连续物理内存。在 L2 页表项描述符种 n 为 21，表示 2MB 连续物理内存。</li><li>当页面粒度为 16KB 时，在 L2 页表项描述符中 n 为 25，表示 32MB 连续的物理内存。</li><li>当页面粒度为 64KB 时，在 L2 页表项描述符中 n 为 29，表示 512MB 连续的物理内存。</li><li>bit[11:2] 为低位属性，bitp[63:52] 为高位属性</li></ul></li></ul></li></ul><h3 id="L3-页表项描述符"><a href="#L3-页表项描述符" class="headerlink" title="L3 页表项描述符"></a>L3 页表项描述符</h3><p>L3 页表项描述包含 5 中页表项</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202310081139705.png" alt="image-20231008113906651"></p><ul><li><p>页表项描述符 bit[0] &#x3D; 0 时，表示无效描述符；bit[0] &#x3D; 1，表示有效描述符</p></li><li><p>页表项描述符 bit[1] &#x3D; 0 时，表示预留的页表项；bit[1] &#x3D; 1，表示页表类型的页表项</p><ul><li>页表粒度为 4KB 时，bit[47:12] 表示最终的物理地址</li><li>页表粒度为 16KB 时，bit[47:14] 表示最终的物理地址</li><li>页表粒度为 64KB 时，bit[47:16] 表示最终的物理地址</li></ul></li><li><p>页表项描述符 bit[11:2] 为低位属性，bit[63:51] 为高位属性</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202310081148952.png" alt="image-20231008114808898"></p></li><li><table><thead><tr><th>名称</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td>AttrIndx[2:0]</td><td>bit[4:2]</td><td>MAIR_ELn 寄存器表示内存属性，如设备内存、普通内存等。软件可以设置 8 种内存属性。常用的有：<br />DEVICE_nGnRnE<br />DEVICE_nGnRE<br />DEVICE_GRE<br />NORMAL_NC<br />NORMAL<br />NORMAL_WT<br />这些值都已经设置到 MAIR_ELn 中了，使用的时候这里选择对应的索引即可。</td></tr><tr><td>NS</td><td>bit[5]</td><td>非安全位。<br />当处于安全模式时用于指定访问的内存地址是安全映射还是非安全映射</td></tr><tr><td>AP[2:1]</td><td>bit[7:6]</td><td>数据访问权限位<br />AP[1] 表示该内存允许通过用户权限（EL0）和更高权限（EL1）来访问。在 linux 内核中使用 <code>PTE_USER</code> 宏来表示可以在用户态访问该页面。<br />1：表示可以通过 EL0 和更高权限访问<br />0：表示不能通过 EL0 访问，但可以通过 EL1 访问<br />AP[2] 表示只读、可读、可写权限。在 linux 内核中使用 <code>PTE_RDONLY</code> 宏来表示该位<br />1：只读<br />0：可读可写</td></tr><tr><td>SH[1:0]</td><td>bit[9:8]</td><td>内存共享属性。在 linux 内核中使用 <code>PTE_SHARED</code> 宏来表示该位<br />00：不共享<br />01：预留<br />10：外部共享<br />11：内部共享</td></tr><tr><td>AF</td><td>bit[10]</td><td>访问位。在 linux 内核中使用 <code>PTE_AF</code> 宏来表示该位<br />当第一次访问页面时硬件会自动设置该位</td></tr><tr><td>nG</td><td>bit[11]</td><td>非全局位。在 linux 内核中使用 <code>PTE_NG</code> 宏来表示该位<br />该位用于管理 TLB。TLB 的页表项分为全局和进程特有的，当设置该位时表示这个 TLB 是进程特有的。</td></tr><tr><td>nT</td><td>bit[16]</td><td>块类型页表项</td></tr><tr><td>DBM</td><td>bit[51]</td><td>脏位。<br />linux 内核中使用 <code>PTE_DBM</code> 宏来表示该位<br />表示页表被修改过</td></tr><tr><td>Contiguous</td><td>bit[52]</td><td>表示当前页表项处于一个连续物理页面中，可以使用单个 TLB 页表项优化<br />linux 内核中使用 <code>PTE_CONT</code> 宏来表示该位</td></tr><tr><td>PXN</td><td>bit[53]</td><td>表示页面在特权模式下不能执行<br />linux 内核中使用 <code>PTE_PXN</code> 来表示该位</td></tr><tr><td>UXN or XN</td><td>bit[54]</td><td>XN 表示页面在任何模式下都不能执行<br />UXN 表示在用户模式下不能执行，linux 内核中使用 <code>PTE_UXN</code> 表示该位</td></tr><tr><td>Reserved for software use</td><td></td><td>预留给软件使用。<br />软件可以利用这些位来实现特殊的功能。如，PTE_DIRTY、PTE_SPECIAL、PTE_PROT_NONE 等</td></tr><tr><td>PBHA</td><td>bit[62:59]</td><td>与页面相关的硬件属性</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></li></ul><h4 id="linux-内核中-L3-页表项属性"><a href="#linux-内核中-L3-页表项属性" class="headerlink" title="linux 内核中 L3 页表项属性"></a>linux 内核中 L3 页表项属性</h4><p><code>arch/arm64/include/asm/pgtable-hwdef.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Level 3 descriptor (PTE).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_TYPE_MASK(_AT(pteval_t, 3) &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_TYPE_FAULT(_AT(pteval_t, 0) &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_TYPE_PAGE(_AT(pteval_t, 3) &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_TABLE_BIT(_AT(pteval_t, 1) &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_USER(_AT(pteval_t, 1) &lt;&lt; 6)<span class="hljs-comment">/* AP[1] */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_RDONLY(_AT(pteval_t, 1) &lt;&lt; 7)<span class="hljs-comment">/* AP[2] */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_SHARED(_AT(pteval_t, 3) &lt;&lt; 8)<span class="hljs-comment">/* SH[1:0], inner shareable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_AF(_AT(pteval_t, 1) &lt;&lt; 10)<span class="hljs-comment">/* Access Flag */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_NG(_AT(pteval_t, 1) &lt;&lt; 11)<span class="hljs-comment">/* nG */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_DBM(_AT(pteval_t, 1) &lt;&lt; 51)<span class="hljs-comment">/* Dirty Bit Management */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_CONT(_AT(pteval_t, 1) &lt;&lt; 52)<span class="hljs-comment">/* Contiguous range */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_PXN(_AT(pteval_t, 1) &lt;&lt; 53)<span class="hljs-comment">/* Privileged XN */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_UXN(_AT(pteval_t, 1) &lt;&lt; 54)<span class="hljs-comment">/* User XN */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_HYP_XN(_AT(pteval_t, 1) &lt;&lt; 54)<span class="hljs-comment">/* HYP XN */</span></span><br></code></pre></td></tr></table></figure><p>上面是 ARMv8 架构的页面项<strong>硬件属性</strong>定义，可以对照上面的表格。</p><p><code>arch/arm64/include/asm/pgtable-prot.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Software defined PTE bits definition.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_VALID(_AT(pteval_t, 1) &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_WRITE(PTE_DBM) <span class="hljs-comment">/* same as DBM (51) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_DIRTY(_AT(pteval_t, 1) &lt;&lt; 55)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_SPECIAL(_AT(pteval_t, 1) &lt;&lt; 56)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_PROT_NONE(_AT(pteval_t, 1) &lt;&lt; 58) <span class="hljs-comment">/* only when !PTE_VALID */</span></span><br></code></pre></td></tr></table></figure><p>bit[58:55] 是硬件预留给软件用的，然后 linux 使用这些位实现了 <code>PTE_DIRTY</code>、<code>PTE_SPECIAL</code>、<code>PTE_PROT_NONE</code> 的几种属性。需要注意，硬件有个 <code>PTE_DBM</code> 来表示页面脏了，而软件也使用 bit[55] 定义了一个 <code>PTE_DIRTY</code> 宏来表示脏页</p><h5 id="查询-PTE-属性"><a href="#查询-PTE-属性" class="headerlink" title="查询 PTE 属性"></a>查询 PTE 属性</h5><p>如查看页表项是否存在，若不存在就表示页表项对应的物理页面不在内存中。对于这些操作，linux 内核中定义了相关的宏，写代码时最好使用这些宏，而不是直接操作那些位。</p><p><code>arch/arm64/include/asm/pgtable.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The following only work if pte_present(). Undefined behaviour otherwise.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_present(pte)(!!(pte_val(pte) &amp; (PTE_VALID | PTE_PROT_NONE)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_young(pte)(!!(pte_val(pte) &amp; PTE_AF))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_special(pte)(!!(pte_val(pte) &amp; PTE_SPECIAL))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_write(pte)(!!(pte_val(pte) &amp; PTE_WRITE))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_user_exec(pte)(!(pte_val(pte) &amp; PTE_UXN))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_cont(pte)(!!(pte_val(pte) &amp; PTE_CONT))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_hw_dirty(pte)(pte_write(pte) &amp;&amp; !(pte_val(pte) &amp; PTE_RDONLY))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_sw_dirty(pte)(!!(pte_val(pte) &amp; PTE_DIRTY))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_dirty(pte)(pte_sw_dirty(pte) || pte_hw_dirty(pte))</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>说明</th><th>处理器实现</th></tr></thead><tbody><tr><td>pte_present</td><td>该页是否在内存中</td><td>判断 <code>PTE_VALID</code> 和 <code>PTE_PROT_NONE</code> 是否置位</td></tr><tr><td>pte_young</td><td>该页是否被访问过</td><td>判断 <code>PTE_AF</code> 是否置位</td></tr><tr><td>pte_write</td><td>该页是否有可写属性</td><td>判断 <code>PTE_DBM</code> 是否置位</td></tr><tr><td>pte_dirty</td><td>该页是否被写入过</td><td>判断硬件的 <code>PTE_DBM</code> 和软件的 <code>PTE_DIRTY</code> 是否置位<br />并且 <code>PTE_RDONLY</code> 没有置位</td></tr><tr><td>pte_hw_dirty</td><td>该页是否硬件设置为脏页</td><td>判断软件的 <code>PTE_DIRTY</code> 是否置位</td></tr><tr><td>pte_sw_dirty</td><td>该页是否软件设置为脏页</td><td>判断硬件的 <code>PTE_DBM</code> 是否置位</td></tr><tr><td>pte_user_exec</td><td>用户是否可以访问该页</td><td>判断 <code>PTE_UXN</code> 是否清零</td></tr><tr><td>pte_cont</td><td>该页是否为连续页</td><td>判断 <code>PTE_CONT</code> 是否置位</td></tr><tr><td>pte_special</td><td>该页是否为特殊用途</td><td>判断 <code>PTE_SPECIAL</code> 是否置位，具体的特殊用途为：<br />1. 内核的零页面 zero page<br />2. 大量的驱动程序使用 <code>remap_pfn_range()</code>来实现映射内核页面到用户空间  <br />3. 调用 <code>vm_insert_page()/vm_insert_pfn()</code>映射内核页面到用户空间</td></tr></tbody></table><p><code>PTE_VALID</code> 好理解，表示该页面是否有效，但是 <code>PTE_PROT_NONE</code> 表示什么呢？我从 linux 源码提交历史中找到了解释，表示该页面在内存中，但是没有读写权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">commit <span class="hljs-number">3676f</span>9ef5481d614f8c5c857f5319755be248268<br>Author: Catalin Marinas                                                                   Date:   Wed Nov <span class="hljs-number">27</span> <span class="hljs-number">16</span>:<span class="hljs-number">59</span>:<span class="hljs-number">27</span> <span class="hljs-number">2013</span> +<span class="hljs-number">0000</span>                                                     <br>    arm64: Move PTE_PROT_NONE higher up <br>    PTE_PROT_NONE means that a pte is present but does not have any                         read/write attributes. However, setting the memory type like                               <span class="hljs-title function_">pgprot_writecombine</span><span class="hljs-params">()</span> is allowed and such bits overlap with                               PTE_PROT_NONE. This causes mmap/munmap issues in drivers that change the                   vma-&gt;vm_pg_prot on PROT_NONE mappings. <br>        <br>    This patch reverts the PTE_FILE/PTE_PROT_NONE shift in commit<br>    59911<span class="hljs-title function_">ca4325d</span> <span class="hljs-params">(ARM64: mm: Move PTE_PROT_NONE bit)</span> and moves PTE_PROT_NONE<br>    together with the other software bits. <br>    Signed-off-by: Steve Capper<br>    Signed-off-by: Catalin Marinas<br>    Tested-by: Steve Capper<br>    Cc:  # 3.11+<br></code></pre></td></tr></table></figure><p>页面脏有硬件和软件两个标志，那应该判断哪个呢？从 <code>pte_dirty</code> 看出，判断只要软件或硬件随便一个标志都行。因为只要硬件 <code>PTE_DBM</code> 标志变化了，在缺页异常流程中就会改变<code>PTE_DIRTY</code> 标志。</p><h5 id="设置-PTE-属性"><a href="#设置-PTE-属性" class="headerlink" title="设置 PTE 属性"></a>设置 PTE 属性</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">clear_pte_bit</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte, <span class="hljs-type">pgprot_t</span> prot)</span><br>&#123;<br>pte_val(pte) &amp;= ~pgprot_val(prot);<br><span class="hljs-keyword">return</span> pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">set_pte_bit</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte, <span class="hljs-type">pgprot_t</span> prot)</span><br>&#123;<br>pte_val(pte) |= pgprot_val(prot);<br><span class="hljs-keyword">return</span> pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_wrprotect</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br>pte = clear_pte_bit(pte, __pgprot(PTE_WRITE));<br>pte = set_pte_bit(pte, __pgprot(PTE_RDONLY));<br><span class="hljs-keyword">return</span> pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkwrite</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br>pte = set_pte_bit(pte, __pgprot(PTE_WRITE));<br>pte = clear_pte_bit(pte, __pgprot(PTE_RDONLY));<br><span class="hljs-keyword">return</span> pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkclean</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br>pte = clear_pte_bit(pte, __pgprot(PTE_DIRTY));<br>pte = set_pte_bit(pte, __pgprot(PTE_RDONLY));<br><br><span class="hljs-keyword">return</span> pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkdirty</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br>pte = set_pte_bit(pte, __pgprot(PTE_DIRTY));<br><br><span class="hljs-keyword">if</span> (pte_write(pte))<br>pte = clear_pte_bit(pte, __pgprot(PTE_RDONLY));<br><br><span class="hljs-keyword">return</span> pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkold</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> clear_pte_bit(pte, __pgprot(PTE_AF));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkyoung</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> set_pte_bit(pte, __pgprot(PTE_AF));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkspecial</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> set_pte_bit(pte, __pgprot(PTE_SPECIAL));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkcont</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br>pte = set_pte_bit(pte, __pgprot(PTE_CONT));<br><span class="hljs-keyword">return</span> set_pte_bit(pte, __pgprot(PTE_TYPE_PAGE));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mknoncont</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> clear_pte_bit(pte, __pgprot(PTE_CONT));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">pte_mkpresent</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> set_pte_bit(pte, __pgprot(PTE_VALID));<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>clear_pte_bit</td><td>清除页表项的某个标志位</td></tr><tr><td>set_pte_bit</td><td>设置页表项的哪些标志位</td></tr><tr><td>pte_wrprotect</td><td>设置写保护。清除 <code>PTE_WRITE</code>，设置 <code>PTE_RDONLY</code></td></tr><tr><td>pte_mkwrite</td><td>使能可写属性。设置<code>PTE_WRITE</code>，清除 <code>PTE_RDONLY</code></td></tr><tr><td>pte_mkclean</td><td>清除脏页标志。清除 <code>PTE_DIRTY</code>，设置 <code>PTE_RDONLY</code></td></tr><tr><td>pte_mkdirty</td><td>让页面变成脏页。设置 <code>PTE_DIRTY</code>，若有可写属性，清除 <code>PTE_RDONLY</code></td></tr><tr><td>pte_mkold</td><td>将页面变成未访问状态。清除 <code>PTE_AF</code></td></tr><tr><td>pte_mkyoung</td><td>将页面变成已访问过状态。设置 <code>PTE_AF</code></td></tr><tr><td>pte_mkspecial</td><td>将页面设置成特殊用途，软件自定义。设置 <code>PTE_SPECIAL</code></td></tr><tr><td>pte_mkcont</td><td>设置连续页面标记。设置 <code>PTE_CONT</code> 和 <code>PTE_TYPE_PAGE</code></td></tr><tr><td>pte_mknoncont</td><td>清除连续页面标记。清除 <code>PTE_CONT</code></td></tr><tr><td>pte_mkpresent</td><td>设置该页面在内存中。设置 <code>PTE_VALID</code></td></tr></tbody></table><h5 id="写硬件-PTE-页表项"><a href="#写硬件-PTE-页表项" class="headerlink" title="写硬件 PTE 页表项"></a>写硬件 PTE 页表项</h5><p>当需要把 pte 页表项写入硬件时，可以调用 <code>set_pte_at</code> 函数，最终调用 <code>set_pte</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * PTE bits configuration in the presence of hardware Dirty Bit Management</span><br><span class="hljs-comment"> * (PTE_WRITE == PTE_DBM):</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Dirty  Writable | PTE_RDONLY  PTE_WRITE  PTE_DIRTY (sw)</span><br><span class="hljs-comment"> *   0      0      |   1           0          0</span><br><span class="hljs-comment"> *   0      1      |   1           1          0</span><br><span class="hljs-comment"> *   1      0      |   1           0          1</span><br><span class="hljs-comment"> *   1      1      |   0           1          x</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When hardware DBM is not present, the sofware PTE_DIRTY bit is updated via</span><br><span class="hljs-comment"> * the page fault mechanism. Checking the dirty status of a pte becomes:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   PTE_DIRTY || (PTE_WRITE &amp;&amp; !PTE_RDONLY)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_pte_at</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params">      <span class="hljs-type">pte_t</span> *ptep, <span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-type">pte_t</span> old_pte;<br><br><span class="hljs-keyword">if</span> (pte_present(pte) &amp;&amp; pte_user_exec(pte) &amp;&amp; !pte_special(pte))<br>__sync_icache_dcache(pte);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the existing pte is valid, check for potential race with</span><br><span class="hljs-comment"> * hardware updates of the pte (ptep_set_access_flags safely changes</span><br><span class="hljs-comment"> * valid ptes without going through an invalid entry).</span><br><span class="hljs-comment"> */</span><br>old_pte = READ_ONCE(*ptep);<br>...<br><br>set_pte(ptep, pte);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_pte</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> *ptep, <span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br>WRITE_ONCE(*ptep, pte);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Only if the new pte is valid and kernel, otherwise TLB maintenance</span><br><span class="hljs-comment"> * or update_mmu_cache() have the necessary barriers.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pte_valid_not_user(pte))<br>dsb(ishst);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pte_valid_not_user(pte) \</span><br><span class="hljs-meta">((pte_val(pte) &amp; (PTE_VALID | PTE_USER | PTE_UXN)) == (PTE_VALID | PTE_UXN))</span><br></code></pre></td></tr></table></figure><p>如果该页面在内存中，并且时用户态映射的内存，就可以调用 <code>__sync_icache_dcache</code> 来进行高速缓存一致性操作。</p><p>第一个参数 ptep 表示要设置的页表项，第二个参数 pte 表示要设置的值。<code>pte_valid_not_user</code> 表示该页不能被用户态访问，说明是内核页面，当被写入硬件页表时，需要调用内存屏障指令 <code>dsb</code> 来保证页表更新完成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/08/linux/kernel/memory/%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E9%83%A8%E5%88%86/"/>
    <url>/2023/10/08/linux/kernel/memory/%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="开机启动中内存相关"><a href="#开机启动中内存相关" class="headerlink" title="开机启动中内存相关"></a>开机启动中内存相关</h1><span id="more"></span><p>在启动汇编代码文件 <code>arch/arm64/kernel/head.S</code> 中，刚开始 MMU 是关闭的，不能使用高速缓存功能，而在后面某个阶段会打开 MMU 并且使能数据高速缓存以提高性能。</p><p><code>Documentation/arm64/booting.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">- Caches, MMUs<br>  The MMU must be off.<br>  Instruction cache may be on or off.<br>  The address range corresponding to the loaded kernel image must be<br>  cleaned to the PoC. In the presence of a system cache or other<br>  coherent masters with caches enabled, this will typically require<br>  cache maintenance by VA rather than <span class="hljs-built_in">set</span>/way operations.<br>  System caches which respect the architected cache maintenance by VA<br>  operations must be configured and may be enabled.<br>  System caches which <span class="hljs-keyword">do</span> not respect architected cache maintenance by VA<br>  <span class="hljs-title function_">operations</span> <span class="hljs-params">(not recommended)</span> must be configured and disabled.<br></code></pre></td></tr></table></figure><ol><li>在关闭 MMU 时处理器访问的是物理地址，在打开 MMU 时处理器访问的时虚拟地址</li><li>现在的大部分的处理器都是流水线架构，处理器会提前预取多条指令到流水线中。当打开 MMU 时，处理器流水线中已经有许多以<strong>物理地址</strong>方式预取的指令，在 MMU 开启后，处理器就会以虚拟地址来访问，然后到 MMU 中查找物理地址。</li></ol><p>所以为了在开启 MMU 前后连续获取指令，并且保证不出错，需要在开启 MMU 前建立恒等映射（identity mapping），而且映射范围很小（通常和内核镜像差不多）</p><h2 id="建立恒等映射"><a href="#建立恒等映射" class="headerlink" title="建立恒等映射"></a>建立恒等映射</h2><p>恒等映射是在 <code>__create_page_tables</code> 中建立的（其中去掉一些无关的分支代码，方便分析）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br> * Setup the initial page tables. We only setup the barest amount which is<br> * required to get the kernel running. The following sections are required:<br> *   - identity mapping to enable the MMU (low address, TTBR0)<br> *   - first few MB of the kernel linear mapping to jump to once the MMU has<br> *     been enabled<br> */<br>__create_page_tables:<br>movx28, lr<br><br>/*<br> * Invalidate the init page tables to avoid potential dirty cache lines<br> * being evicted. Other page tables are allocated in rodata as part of<br> * the kernel image, and thus are clean to the PoC per the boot<br> * protocol.<br> */<br>adrpx0, init_pg_dir<br>adrpx1, init_pg_end<br>subx1, x1, x0<br>bl__inval_dcache_area<br><br>/*<br> * Clear the init page tables.<br> */<br>adrpx0, init_pg_dir<br>adrpx1, init_pg_end<br>subx1, x1, x0<br>1:stpxzr, xzr, [x0], #16<br>stpxzr, xzr, [x0], #16<br>stpxzr, xzr, [x0], #16<br>stpxzr, xzr, [x0], #16<br>subsx1, x1, #64<br>b.ne1b<br><br>movx7, SWAPPER_MM_MMUFLAGS<br><br>/*<br> * Create the identity mapping.<br> */<br>adrpx0, idmap_pg_dir<br>adrpx3, __idmap_text_start// __pa(__idmap_text_start)<br><br>movx5, #VA_BITS<br>1:<br>adr_lx6, vabits_user<br>strx5, [x6]<br>dmbsy<br>dcivac, x6// Invalidate potentially stale cache line<br><br>adrpx5, __idmap_text_end<br>clzx5, x5<br>cmpx5, TCR_T0SZ(VA_BITS)// default T0SZ small enough?<br>b.ge1f// .. then skip VA range extension<br><br>adr_lx6, idmap_t0sz<br>strx5, [x6]<br>dmbsy<br>dcivac, x6// Invalidate potentially stale cache line<br><br>movx4, #1 &lt;&lt; (PHYS_MASK_SHIFT - PGDIR_SHIFT)<br>str_lx4, idmap_ptrs_per_pgd, x5<br>1:<br>ldr_lx4, idmap_ptrs_per_pgd<br>movx5, x3// __pa(__idmap_text_start)<br>adr_lx6, __idmap_text_end// __pa(__idmap_text_end)<br><br>map_memory x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14<br></code></pre></td></tr></table></figure><p>第 9 行把 lr 放到 X28 临时寄存器中</p><p>第 17、18 行加载 <code>init_pg_dir</code> 和 <code>init_pg_end</code> 到 X0、X1 中</p><p><code>init_pg_dir</code> 和 <code>init_pg_end</code> 定义在链接器脚本 <code>arch/arm64/kernel/vmlinux.lds.S</code> 中，此页表大小为 INIT_DIR_SIZE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">. = ALIGN(PAGE_SIZE);<br>init_pg_dir = .;<br>. += INIT_DIR_SIZE;<br>init_pg_end = .;<br></code></pre></td></tr></table></figure><p>第 19 行，将页表大小存入 X1 寄存器</p><p>第 20 行调用 <code>__inval_dcache_area</code> 将 init_pg_dir 页表的高速缓存行无效，因为一会儿会建立内核空间的页表映射</p><p>第 25 ~ 33 行，循环将 init_pg_dir 页表清零</p><p>第 35 行 宏 SWAPPER_MM_MMUFLAGS 描述了段映射属性，定义为普通内存，PMD_TYPE_SECT 表示块映射，PMD_SECT_AF 表示可访问，PMD_SECT_S 表示共享属性</p><p><code>arch/arm64/include/asm/kernel-pgtable.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPPER_PMD_FLAGS(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPPER_MM_MMUFLAGS(PMD_ATTRINDX(MT_NORMAL) | SWAPPER_PMD_FLAGS)</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/pgtable-hwdef.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_TYPE_SECT(_AT(pmdval_t, 1) &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_SECT_AF(_AT(pmdval_t, 1) &lt;&lt; 10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_SECT_S(_AT(pmdval_t, 3) &lt;&lt; 8)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_ATTRINDX(t)(_AT(pmdval_t, (t)) &lt;&lt; 2)</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/memory.h</code><a id="内存属性"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Memory types available.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MT_DEVICE_nGnRnE0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MT_DEVICE_nGnRE1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MT_DEVICE_GRE2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MT_NORMAL_NC3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MT_NORMAL4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MT_NORMAL_WT5</span><br></code></pre></td></tr></table></figure><p>详见 <strong>ARM Cortex-A Series Programmer’s Guide for ARMv8-A</strong> 手册 201 页</p><p>第 40 行将 idmap_pg_dir 的物理地址载入 X0 寄存器，此为恒等映射页表，其定义在 vmlinux.lds.S 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">. = ALIGN(PAGE_SIZE);<br>idmap_pg_dir = .;<br>. += IDMAP_DIR_SIZE;<br></code></pre></td></tr></table></figure><p>页表大小为 IDMAP_DIR_SIZE，3 个连续页面，定义在 <code>arch/arm64/include/asm/kernel-pgtable.h</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDMAP_PGTABLE_LEVELS(ARM64_HW_PGTABLE_LEVELS(PHYS_MASK_SHIFT) - 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDMAP_DIR_SIZE(IDMAP_PGTABLE_LEVELS * PAGE_SIZE)</span><br></code></pre></td></tr></table></figure><p><code>include/generated/autoconf.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_ARM64_PA_BITS 48</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/pgtable-hwdef.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHYS_MASK_SHIFT   (CONFIG_ARM64_PA_BITS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARM64_HW_PGTABLE_LEVELS(va_bits) (((va_bits) - 4) / (PAGE_SHIFT - 3))</span><br></code></pre></td></tr></table></figure><p>很明显，这里的 3 个页面分表表示 PGD、PUD、PMD 页表，注意这里建立的是 2M 大小的块映射，而不是 4K 的页面映射</p><p>第 41 行将 __idmap_text_start 载入 X3 寄存器，其为 .idmap.text 段的起始地址，除了开机启动 MMU 外，还有很多地方需要恒等映射，如唤醒处理器函数 cpu_do_resume</p><p>第 43 行 VA_BITS 为虚拟地址宽度，默认为 48 位，.config 文件中一般配置 CONFIG_ARM64_VA_BITS&#x3D;48</p><p>第 45 ~ 48 行，将 VA_BITS 存入 vabits_user 全局变量，并且清楚其对应的高速缓存</p><p>第 50 ~ 53 行，判断 __idmap_text_end 是否超过了 VA_BITS 所能达到的地址范围，若没有超过跳到下面的 1 处</p><p>第 63 行，将 idmap_ptrs_per_pgd 放入 X4 寄存器，idmap_ptrs_per_pgd 表示每个 PGD 中有多少页表项，它的值等于 PTRS_PER_PGD，定义在 <code>arch/arm64/include/asm/pgtable-hwdef.h</code> 中，若配置为 4 级页表，PTRS_PER_PGD 等于 512</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGDIR_SHIFTARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGDIR_SIZE(_AC(1, UL) &lt;&lt; PGDIR_SHIFT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGDIR_MASK(~(PGDIR_SIZE-1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTRS_PER_PGD(1 &lt;&lt; (MAX_USER_VA_BITS - PGDIR_SHIFT))</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/memory.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_USER_VA_BITSVA_BITS<span class="hljs-comment">// 48</span></span><br></code></pre></td></tr></table></figure><p><code>include/generated/autoconf.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PGTABLE_LEVELS 4</span><br></code></pre></td></tr></table></figure><p><code>arch/arm64/include/asm/pgtable-hwdef.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Size mapped by an entry at level n ( 0 &lt;= n &lt;= 3)</span><br><span class="hljs-comment"> * We map (PAGE_SHIFT - 3) at all translation levels and PAGE_SHIFT bits</span><br><span class="hljs-comment"> * in the final page. The maximum number of translation levels supported by</span><br><span class="hljs-comment"> * the architecture is 4. Hence, starting at at level n, we have further</span><br><span class="hljs-comment"> * ((4 - n) - 1) levels of translation excluding the offset within the page.</span><br><span class="hljs-comment"> * So, the total number of bits mapped by an entry at level n is :</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  ((4 - n) - 1) * (PAGE_SHIFT - 3) + PAGE_SHIFT</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Rearranging it a bit we get :</span><br><span class="hljs-comment"> *   (4 - n) * (PAGE_SHIFT - 3) + 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARM64_HW_PGTABLE_LEVEL_SHIFT(n)((PAGE_SHIFT - 3) * (4 - (n)) + 3)</span><br></code></pre></td></tr></table></figure><p>第 64 行，__idmap_text_start 物理地址存入 X5 寄存器</p><p>第 65 行，__idmap_text_end 物理地址存入 X6 寄存器</p><p>第 67 行，调用 map_memory 宏映射页表，这里再统一整理下参数列表</p><p><code>map_memory</code> 也定义在 <code>arch/arm64/kernel/head.S</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br> * Map memory for specified virtual address range. Each level of page table needed supports<br> * multiple entries. If a level requires n entries the next page table level is assumed to be<br> * formed from n pages.<br> *<br> *tbl:location of page table<br> *rtbl:address to be used for first level page table entry (typically tbl + PAGE_SIZE)<br> *vstart:start address to map<br> *vend:end address to map - we map [vstart, vend]<br> *flags:flags to use to map last level entries<br> *phys:physical address corresponding to vstart - physical memory is contiguous<br> *pgds:the number of pgd entries<br> *<br> * Temporaries:istart, iend, tmp, count, sv - these need to be different registers<br> * Preserves:vstart, vend, flags<br> * Corrupts:tbl, rtbl, istart, iend, tmp, count, sv<br> */<br>.macro map_memory, tbl, rtbl, vstart, vend, flags, phys, pgds, istart, iend, tmp, count, sv<br>add \rtbl, \tbl, #PAGE_SIZE<br>mov \sv, \rtbl<br>mov \count, #0<br>compute_indices \vstart, \vend, #PGDIR_SHIFT, \pgds, \istart, \iend, \count<br>populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp<br>mov \tbl, \sv<br>mov \sv, \rtbl<br><br>compute_indices \vstart, \vend, #SWAPPER_TABLE_SHIFT, #PTRS_PER_PMD, \istart, \iend, \count<br>populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp<br>mov \tbl, \sv<br><br>compute_indices \vstart, \vend, #SWAPPER_BLOCK_SHIFT, #PTRS_PER_PTE, \istart, \iend, \count<br>bic \count, \phys, #SWAPPER_BLOCK_SIZE - 1<br>populate_entries \tbl, \count, \istart, \iend, \flags, #SWAPPER_BLOCK_SIZE, \tmp<br>.endm<br><br></code></pre></td></tr></table></figure><p>tbl: 页表的起始地址</p><p>rtbl: 下一级页表的首地址，通常为 tlb + PAGE_SIZE</p><p>vstart: 要映射的虚拟首地址</p><p>vend: 要映射的虚拟结束地址</p><p>flags: 最后一级页表的属性</p><p>phys: 映射对应的物理首地址</p><p>pgds: PGD 的页表项个数</p><p>其他参数都是临时的</p><p>回到调用 <code>map_memory</code> 的地方，列车各个参数的值 x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>rbl</td><td>x0(idmap_pg_dir)</td></tr><tr><td>rtbl</td><td>idmap_pg_dir + PAGE_SIZE</td></tr><tr><td>vstart</td><td>__idmap_text_start</td></tr><tr><td>vend</td><td>__idmap_text_end</td></tr><tr><td>flags</td><td>SWAPPER_MM_MMUFLAGS</td></tr><tr><td>phys</td><td>__idmap_text_start</td></tr><tr><td>pgds</td><td>idmap_ptrs_per_pgd(PTRS_PER_PGD)</td></tr></tbody></table><p>虚拟地址 vstart 和物理地址 phys 为什么一样呢？其实恒等映射就是相同的虚拟地址和物理地址做映射，才能在打开 MMU 前后丝滑的转换</p><p>第 19 行，rtbl 指向了下一个页表首地址。之前说过恒等映射分配了连续 3 个页面的空间，所以 rbl + PAGE_SIZE 就是 PUD 的首地址了</p><p>第 22 行，调用 <code>compute_indices</code> 宏计算 vstart 和 vend 在各自页表中的索引值</p><p>第 23 行，调用 <code>populate_entries</code> 来设置页表项的内容</p><p>第 22 ~ 23 行，设置第一级页表 PGD 的页表项</p><p>第 27 ~ 28 行，设置第二级页表 PMD 的页表项</p><p>第 31 ~ 32 行，设置最后一级页表 PT 的页表项</p><p>这里看一下 <code>compute_indices</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br> * Compute indices of table entries from virtual address range. If multiple entries<br> * were needed in the previous page table level then the next page table level is assumed<br> * to be composed of multiple pages. (This effectively scales the end index).<br> *<br> *vstart:virtual address of start of range<br> *vend:virtual address of end of range<br> *shift:shift used to transform virtual address into index<br> *ptrs:number of entries in page table<br> *istart:index in table corresponding to vstart<br> *iend:index in table corresponding to vend<br> *count:On entry: how many extra entries were required in previous level, scales<br> *  our end index.<br> *On exit: returns how many extra entries required for next page table level<br> *<br> * Preserves:vstart, vend, shift, ptrs<br> * Returns:istart, iend, count<br> */<br>.macro compute_indices, vstart, vend, shift, ptrs, istart, iend, count<br>lsr\iend, \vend, \shift<br>mov\istart, \ptrs<br>sub\istart, \istart, #1<br>and\iend, \iend, \istart// iend = (vend &gt;&gt; shift) &amp; (ptrs - 1)<br>mov\istart, \ptrs<br>mul\istart, \istart, \count<br>add\iend, \iend, \istart// iend += (count - 1) * ptrs<br>// our entries span multiple tables<br><br>lsr\istart, \vstart, \shift<br>mov\count, \ptrs<br>sub\count, \count, #1<br>and\istart, \istart, \count<br><br>sub\count, \iend, \istart<br>.endm<br></code></pre></td></tr></table></figure><p>vstart: 虚拟首地址</p><p>vend: 虚拟结束地址</p><p>shift: 各级页表在虚拟地址中的偏移量</p><p>ptrs: 各级页表中的页表项个数</p><p>istart: vstart 对应的索引值</p><p>iend: vend 对应的索引值</p><p>再次列出调用时的参数值</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>vstart</td><td>__idmap_text_start</td></tr><tr><td>vend</td><td>__idmap_text_end</td></tr><tr><td>shift</td><td>PGDIR_SHIFT</td></tr><tr><td>ptrs</td><td>idmap_ptrs_per_pgd(PTRS_PER_PGD)</td></tr><tr><td>count</td><td>0</td></tr></tbody></table><p>基本就是下面这样计算的：</p><p>istart &#x3D; (vstart &gt;&gt; shift) &amp; (ptrs - 1)</p><p>iend &#x3D; (vend &gt;&gt; shift) &amp; (ptrs - 1)</p><p>这里看一些 <code>populate_entries</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br> * Macro to populate page table entries, these entries can be pointers to the next level<br> * or last level entries pointing to physical memory.<br> *<br> *tbl:page table address<br> *rtbl:pointer to page table or physical memory<br> *index:start index to write<br> *eindex:end index to write - [index, eindex] written to<br> *flags:flags for pagetable entry to or in<br> *inc:increment to rtbl between each entry<br> *tmp1:temporary variable<br> *<br> * Preserves:tbl, eindex, flags, inc<br> * Corrupts:index, tmp1<br> * Returns:rtbl<br> */<br>.macro populate_entries, tbl, rtbl, index, eindex, flags, inc, tmp1<br>.Lpe\@:phys_to_pte \tmp1, \rtbl<br>orr\tmp1, \tmp1, \flags// tmp1 = table entry<br>str\tmp1, [\tbl, \index, lsl #3]<br>add\rtbl, \rtbl, \inc// rtbl = pa next level<br>add\index, \index, #1<br>cmp\index, \eindex<br>b.ls.Lpe\@<br>.endm<br></code></pre></td></tr></table></figure><p>tbl: 页表首地址</p><p>rtbl: 下一级页表的基地址</p><p>index: vstart 在页表中的索引</p><p>eindex: vend 在页表中的索引</p><p>flags: 页表项的属性</p><p>inc: 每一个页表项</p><p>tmp1: 临时使用</p><p>回到第一次调用 <code>compute_indices</code> 的位置查看其参数值</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>tbl</td><td>idmap_pg_dir</td></tr><tr><td>rtlb</td><td>idmap_pg_dir + PAGE_SIZE</td></tr><tr><td>index</td><td>调用 compute_indices 返回的 istart</td></tr><tr><td>eindex</td><td>调用 compute_indices 返回的 iend</td></tr><tr><td>flags</td><td>PMD_TYPE_TABLE</td></tr><tr><td>inc</td><td>PAGE_SIZE</td></tr></tbody></table><p>第 18 ~ 20 行，将下一级页表首地址 + 属性 PMD_TYPE_TABLE 设置到对应的页表项中，即页表首地址 + index * 8</p><p>第 21 ~ 24 行，index + 1，设置后面的页表项，即 index ~ eindex 间所有的页表项，这里其实只设置一次，因为只有一个 PUD 设置到 PGD 中</p><p>综上所述，<code>__create_page_tables</code> 中的 <code>map_memory</code> 就创建了一个把 <code>.idmap.text</code> 段虚拟地址映射到相同物理地址上的恒等映射，映射的页表在 <code>idmap_pg_dir</code> 中</p><p>我使用的 qemu 中物理起始地址为 0x40000000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[    <span class="hljs-number">0.000000</span>]     start memory  : <span class="hljs-number">0x40000000</span><br></code></pre></td></tr></table></figure><p>我们可以从 System.map 中找到哪些函数映射到了 .idmap.text 段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">ffff0000118d4000 T __idmap_text_start<br><br>ffff0000118d4000 T kimage_vaddr<br>ffff0000118d4008 T el2_setup<br>ffff0000118d405c t set_hcr<br>ffff0000118d412c t install_el2_stub<br>ffff0000118d4180 t set_cpu_boot_mode_flag<br>ffff0000118d41a4 T secondary_holding_pen<br>ffff0000118d41c8 t pen<br>ffff0000118d41dc T secondary_entry<br>ffff0000118d41e8 t secondary_startup<br>ffff0000118d4200 t __secondary_switched<br>ffff0000118d4234 T __enable_mmu<br>ffff0000118d428c T __cpu_secondary_check52bitva<br>ffff0000118d4290 t __no_granule_support<br>ffff0000118d42b4 t __relocate_kernel<br>ffff0000118d4300 t __primary_switch<br>ffff0000118d4378 T cpu_resume<br>ffff0000118d4398 T __cpu_soft_restart<br>ffff0000118d43d8 T cpu_do_resume<br>ffff0000118d444c T idmap_cpu_replace_ttbr1<br>ffff0000118d4480 t __idmap_kpti_flag<br>ffff0000118d4484 T idmap_kpti_install_ng_mappings<br>ffff0000118d44c0 t do_pgd<br>ffff0000118d44d8 t next_pgd<br>ffff0000118d44e8 t skip_pgd<br>ffff0000118d451c t walk_puds<br>ffff0000118d4524 t do_pud<br>ffff0000118d453c t next_pud<br>ffff0000118d454c t skip_pud<br>ffff0000118d455c t walk_pmds<br>ffff0000118d4564 t do_pmd<br>ffff0000118d457c t next_pmd<br>ffff0000118d458c t skip_pmd<br>ffff0000118d459c t walk_ptes<br>ffff0000118d45a4 t do_pte<br>ffff0000118d45c8 t skip_pte<br>ffff0000118d45d8 t __idmap_kpti_secondary<br>ffff0000118d4620 T __cpu_setup<br><br>ffff0000118d46b8 T __idmap_text_end<br></code></pre></td></tr></table></figure><p>可以看到恒等映射的段在内核镜像里</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309211013999.png" alt="image-20230921101313940"></p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309210957262.png" alt="image-20230921095715143"></p><p>那为什么这些函数就到了 .idmap.text 中，而其他函数没有呢？</p><p>head.S 中有一行是这样写的，表示从这行开始后面的函数（<code>.pushsection &quot;.mmuoff.data.write&quot;, &quot;aw&quot;</code> 之前）都放入 .idmap.text 段，并且有可分配、可写、可执行的权限，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.section &quot;.idmap.text&quot;,&quot;awx&quot;<br></code></pre></td></tr></table></figure><p>可以看到 kimage_vaddr 和 el2_setup 函数就是 System.map 中 .idmap.text 开始的前两个函数</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309210958831.png" alt="image-20230921095828771"></p><h2 id="建立内核映像页表"><a href="#建立内核映像页表" class="headerlink" title="建立内核映像页表"></a>建立内核映像页表</h2><p>在 <code>__create_page_tables</code> 恒等映射后面就是内核映像映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br> * Map the kernel image (starting with PHYS_OFFSET).<br> */<br>adrpx0, init_pg_dir<br>mov_qx5, KIMAGE_VADDR + TEXT_OFFSET// compile time __va(_text)<br>addx5, x5, x23// add KASLR displacement<br>movx4, PTRS_PER_PGD<br>adrpx6, _end// runtime __pa(_end)<br>adrpx3, _text// runtime __pa(_text)<br>subx6, x6, x3// _end - _text<br>addx6, x6, x5// runtime __va(_end)<br><br>map_memory x0, x1, x5, x6, x7, x3, x4, x10, x11, x12, x13, x14<br><br>/*<br> * Since the page tables have been populated with non-cacheable<br> * accesses (MMU disabled), invalidate the idmap and swapper page<br> * tables again to remove any speculatively loaded cache lines.<br> */<br>adrpx0, idmap_pg_dir<br>adrpx1, init_pg_end<br>subx1, x1, x0<br>dmbsy<br>bl__inval_dcache_area<br><br>retx28<br>ENDPROC(__create_page_tables)<br></code></pre></td></tr></table></figure><p>第 4 行，将内核页表的基地址 init_pg_dir 存入 X0</p><p>第 5 行，将内核映像虚拟地址首地址 KIMAGE_VADDR + TEXT_OFFSET 存入 X5</p><p>第 6 行，内核映像虚拟地址加上 KASLR 的值，使内核映像地址随机化，减小内存访问风险，x23 &#x3D; __PHYS_OFFSET，在启动代码入口设置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ENTRY(stext)<br>blpreserve_boot_args<br>blel2_setup// Drop to EL1, w0=cpu_boot_mode<br>adrpx23, __PHYS_OFFSET<br></code></pre></td></tr></table></figure><p>第 7 行，将 PTRS_PER_PGD，即 PGD 的页表项个数，存入 X4</p><p>第 8 行，将内核映像的物理结束地址存入 X6</p><p>第 9 行，将内核映像的物理首地址存入 X3</p><p>第 10 行，将内核映像的大小存入 X6</p><p>第 11 行，将内核映像的虚拟首地址存入 X6</p><p>第 13 行，调用 <code>map_memory</code> 建立页表映射</p><p>第 20 ~ 24 行，使恒等映像页表 idmap_pg_dir 和内核映像页表 init_pg_dir 对应的高速缓存无效，虽然还没使能 MMU，但数据有可能被预取到高速缓存中，因此要先清除</p><p>第 26 行，函数返回</p><p>综上所述，<code>__create_page_tables </code> 建立了两个映射，.idmap.text 段的恒等映射和内核映像的页表映射，那为什么要创建两个页表，而不是一个呢？</p><p>ARM64 有两个页表基地址寄存器，TTBR0 和 TTBR1，当虚拟地址的第 63 位为 0 时使用 TTBR0，当第 63 位为 1 时使用 TTBR1</p><p>在未开启 MMU 前使用的是物理地址，而且物理地址较小，第 63 位为 0，在开启 MMU 后的瞬间，MMU 访问的虚拟地址其实就是相同的很小的物理地址，所以此时要用 TTBR0，</p><p>也就是说恒等映射使用 TTBR0，而把内核映像映射到内核空间（高 256T）时使用 TTBR1，后面 <code>__enable_mmu</code> 函数中会加载这两个页表</p><p><strong>注意 init_pg_dir 位粗粒度的页表，因为内核映像很小，没必要做细粒度（如 4KB）的映射，后面会使用 <code>swapper_pg_dir</code> 作为细粒度的页表，然后就会丢弃掉 <code>idmap_pg_dir</code> 和 <code>init_pg_dir</code></strong> </p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309211011374.png" alt="image-20230921101142271"></p><h2 id="设置系统内存属性"><a href="#设置系统内存属性" class="headerlink" title="设置系统内存属性"></a>设置系统内存属性</h2><p>mmu 初始化在 <code>__cpu_setup</code> 中完成，定义在 <code>arch/arm64/mm/proc.S</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br> *__cpu_setup<br> *<br> *Initialise the processor for turning the MMU on.  Return in x0 the<br> *value of the SCTLR_EL1 register.<br> */<br>.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;<br>ENTRY(__cpu_setup)<br>tlbivmalle1// Invalidate local TLB<br>dsbnsh<br><br>movx0, #3 &lt;&lt; 20<br>msrcpacr_el1, x0// Enable FP/ASIMD<br>movx0, #1 &lt;&lt; 12// Reset mdscr_el1 and disable<br>msrmdscr_el1, x0// access to the DCC from EL0<br>isb// Unmask debug exceptions now,<br>enable_dbg// since this is per-cpu<br>reset_pmuserenr_el0 x0// Disable PMU access from EL0<br>/*<br> * Memory region attributes for LPAE:<br> *<br> *   n = AttrIndx[2:0]<br> *nMAIR<br> *   DEVICE_nGnRnE00000000000<br> *   DEVICE_nGnRE00100000100<br> *   DEVICE_GRE01000001100<br> *   NORMAL_NC01101000100<br> *   NORMAL10011111111<br> *   NORMAL_WT10110111011<br> */<br>ldrx5, =MAIR(0x00, MT_DEVICE_nGnRnE) | \<br>     MAIR(0x04, MT_DEVICE_nGnRE) | \<br>     MAIR(0x0c, MT_DEVICE_GRE) | \<br>     MAIR(0x44, MT_NORMAL_NC) | \<br>     MAIR(0xff, MT_NORMAL) | \<br>     MAIR(0xbb, MT_NORMAL_WT)<br>msrmair_el1, x5<br>/*<br> * Prepare SCTLR<br> */<br>mov_qx0, SCTLR_EL1_SET<br>/*<br> * Set/prepare TCR and TTBR. We use 512GB (39-bit) address range for<br> * both user and kernel.<br> */<br>ldrx10, =TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \<br>TCR_TG_FLAGS | TCR_KASLR_FLAGS | TCR_ASID16 | \<br>TCR_TBI0 | TCR_A1 | TCR_KASAN_FLAGS<br><br>ldr_lx9, idmap_t0sz<br>tcr_set_t0szx10, x9<br><br>/*<br> * Set the IPS bits in TCR_EL1.<br> */<br>tcr_compute_pa_size x10, #TCR_IPS_SHIFT, x5, x6<br>#ifdef CONFIG_ARM64_HW_AFDBM<br>/*<br> * Enable hardware update of the Access Flags bit.<br> * Hardware dirty bit management is enabled later,<br> * via capabilities.<br> */<br>mrsx9, ID_AA64MMFR1_EL1<br>andx9, x9, #0xf<br>cbzx9, 1f<br>orrx10, x10, #TCR_HA// hardware Access flag update<br>1:<br>#endif/* CONFIG_ARM64_HW_AFDBM */<br>msrtcr_el1, x10<br>ret// return to head.S<br>ENDPROC(__cpu_setup)<br></code></pre></td></tr></table></figure><p>可以看到此函数也在 .idmap.text 段中</p><p>第 9 ~ 10 行，使 EL1 上所有 tlb 无效，并插入内存屏障指令确保指令完成</p><p>…</p><p>第 19 ~ 37 行，设置系统内存属性，linux 只使用了 6 种属性，分两大类</p><p>NORMAL（普通内存，如 dram，可 cache）：</p><ul><li>写入具有 Normal 内存类型的内存位置(Inner 和 Outer 可缓存性均为 Non-cacheable 或 Write-through<br>cacheable)必须在有限的时间内到达内存系统中该位置的端点。对同一位置的两次写操作(其中至少有一次使用 Normal 内存类型)可能会在到达端点之前合并，除非两次写操作之间存在顺序前关系</li><li>支持不对齐访问</li><li>Normal 内存属性适用于幂等（是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同，也就是说对于同一个地址，多次读和读一次的结果是一样的）的内存位置，这意味着它们具有以下所有属性:<ul><li>读取访问可以重复，没有副作用</li><li>多次重复读取返回最后一次写入的值</li><li>读取访问可以在没有副作用的情况下获取额外的内存位置</li><li>如果在重复写操作之间所访问位置的内容没有改变，或者由于出现异常，则可以重复写访问而没有副作用</li><li>内存访问操作可以在访问目标内存系统之前合并</li></ul></li><li>对于访问普通内存，需要 DMB 指令来确保所需的顺序。</li></ul><p>DEVICE：设备内存，通常用于外设，如 usb、uart 等，不可以 cache</p><table><thead><tr><th>内存类型</th><th>解释</th></tr></thead><tbody><tr><td>MT_NORMAL</td><td>普通内存，可以 cache</td></tr><tr><td>MT_NORMAL_NC</td><td>普通内存，不可以 cache</td></tr><tr><td>MT_NORMAL_WT</td><td>普通内存，cache 和 内存同时写</td></tr><tr><td>MT_DEVICE_nGnRnE</td><td>设备内存，不聚合、不重排、不提前 ack</td></tr><tr><td>MT_DEVICE_nGnRE</td><td>设备内存，不聚合、不重排、可提前 ack</td></tr><tr><td>MT_DEVICE_GRE</td><td>设备内存，可聚合、可重排、可提前 ack</td></tr></tbody></table><p>使用的 MAIR 宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAIR(attr, mt)((attr) &lt;&lt; ((mt) * 8))</span><br></code></pre></td></tr></table></figure><p><a href="#内存属性">对于内存属性，前面有介绍过</a></p><p>以上 6 种内存属性会设置到 MAIR 寄存器中的 Attr0 ~ Attr5 中，以后页表项中的属性可以选择 MAIR 的 index 来表示自己的内存属性</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309210959118.png" alt="image-20230921095904064"></p><p>举个例子，看寄存器的值是怎么设置的</p><p>我们看 DEVICE_nGnRE，要将它的值 0x00000100 设置到 0x001 * 8 的位置，即 Attr1，那 0x00000100 为什么表示 DEVICE_nGnRE 呢？</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309211003182.png" alt="image-20230921100314122"></p><p>看到设备内存由 bit[3:2] 决定，DEVICE_nGnRE 刚好是 01，所以最终值就是 0x0000<strong>01</strong>00</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309211003979.png" alt="image-20230921100350937"></p><p>第 46 ~ 69 设置 TCR 相关，用于管理页表映射的（后续专门写）</p><h2 id="使能-MMU"><a href="#使能-MMU" class="headerlink" title="使能 MMU"></a>使能 MMU</h2><p>下来该调用 <code>__primary_switch</code> 和 <code>__enable_mmu</code> 了，这两个函数也在 .idmap.text 段中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__primary_switch:<br>adrpx1, init_pg_dir<br>bl__enable_mmu<br>...<br>ldrx8, =__primary_switched<br>adrpx0, __PHYS_OFFSET<br>brx8<br>ENDPROC(__primary_switch)<br></code></pre></td></tr></table></figure><p>第 2 行，将 内核映像 PGD 页表首地址 init_pg_dir 存入 X1</p><p>第 3 行，调用 <code>__enable_mmu</code> 使能 MMU，这里有两个参数，第一个参数是在 <code>__cpu_setup</code> 中写入 X0 的 SCTRL_EL1，第二个参数为 init 页表的 PGD 首地址</p><p>第 5 ~ 7 行，将 <code>__PHYS_OFFSET</code> 存入 x0，调用 __<code>primary_switched</code> 函数</p><p>这里看 <code>__enable_mmu</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br> * Enable the MMU.<br> *<br> *  x0  = SCTLR_EL1 value for turning on the MMU.<br> *  x1  = TTBR1_EL1 value<br> *<br> * Returns to the caller via x30/lr. This requires the caller to be covered<br> * by the .idmap.text section.<br> *<br> * Checks if the selected granule size is supported by the CPU.<br> * If it isn&#x27;t, park the CPU<br> */<br>ENTRY(__enable_mmu)<br>mrsx2, ID_AA64MMFR0_EL1<br>ubfxx2, x2, #ID_AA64MMFR0_TGRAN_SHIFT, 4<br>cmpx2, #ID_AA64MMFR0_TGRAN_SUPPORTED<br>b.ne__no_granule_support<br>update_early_cpu_boot_status 0, x2, x3<br>adrpx2, idmap_pg_dir<br>phys_to_ttbr x1, x1<br>phys_to_ttbr x2, x2<br>msrttbr0_el1, x2// load TTBR0<br>offset_ttbr1 x1<br>msrttbr1_el1, x1// load TTBR1<br>isb<br>msrsctlr_el1, x0<br>isb<br>/*<br> * Invalidate the local I-cache so that any instructions fetched<br> * speculatively from the PoC are discarded, since they may have<br> * been dynamically patched at the PoU.<br> */<br>iciallu<br>dsbnsh<br>isb<br>ret<br>ENDPROC(__enable_mmu)<br></code></pre></td></tr></table></figure><p>第 14 ~ 16 行，ID_AA64MMFR0_EL1 寄存器中保存着系统支持物理页面的粒度，如 4KB、16KB、64KB，读出来与内核配置的 CONFIG_ARM64_4K_PAGES 比较</p><p>第 18 行，更新全局变量 update_early_cpu_boot_status 的值为 0</p><p>第 19 行，加载恒等映射 PGD 页表 idmap_pg_dir 到 X2</p><p>第 20 ~ 24 行，将恒等映射页表加载到 ttbr0_el1，开启 MMU 之后，在切换进程时 ttbr0_el1 会变成对应进程的 PGD 首地址，将 init 页表加载到 ttbr1_el1，内核态共享这个页表</p><p>第 26 行，设置系统控制寄存器 SCTRL_EL1 的 M 域，使能 MMU</p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309211004547.png" alt="image-20230921100414498"></p><p><img src="https://raw.githubusercontent.com/xiaoaniubi/PicGo/main/img/202309211009173.png" alt="image-20230921100917126"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
